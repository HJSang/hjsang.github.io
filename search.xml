<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Note for Deep Crossing</title>
      <link href="2021/01/16/Note-for-Deep-Crossing/"/>
      <url>2021/01/16/Note-for-Deep-Crossing/</url>
      
        <content type="html"><![CDATA[<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.kdd.org/kdd2016/papers/files/adf0975-shanA.pdf">Deep Crossing: Web-Scale Modeling without Manually Crafted Combinatorial Features</a></li></ul><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li>Before Deep Crossing: manually design combinatorial features or use xgb to design features. Highy depend on experience and domain knlowedge.</li><li>In this paper, the authors proposes the Deep Crossing model:<ul><li>A deep neural network that automatically combines features to produce superior models</li><li>The input is a set of individual features that can be either dense or sparse</li><li>The important corssing features are discovered implicitly by the networks</li></ul></li></ul><h2 id="Sponsored-Search"><a href="#Sponsored-Search" class="headerlink" title="Sponsored Search"></a>Sponsored Search</h2><ul><li>Deep Crossing is discussed in the context of <strong>sponsered search</strong>: showing ads alongside organic search results</li><li>There are three major agents: the user, the advertiser and the search platform</li><li>The below are the concepts ke y to the discussion:<ul><li>Query: A text string a user types into the search box</li><li>Keyword: A text string related to a product, specified by an advertiser to match a user query</li><li>Title: The title of a sponsered advertisement</li><li>Landing page: A product’s web site a user reahes when the corresponding ad is clicked by a user</li><li>Match Type: An option given to the advertiser on how closely the keyword should be matched by a user query, usually one of four kinds:  exact, phrase, broad and contextual</li><li>Campaign: A set of ads that share the same setting such as budget and location targeting, often used to organize products into categories</li><li>Impression: An instance of an ad being displayed to a user. An impression is usually logged with other information available at the run-time</li><li>Click: An indication of whether an impression was clicked by a user.</li><li>Click through rate: Total number of clicks over total number of impressions</li><li>click Prediction: A critical model of the platform that predicts the likelihood a user clicks on a given ad for a given query</li></ul></li></ul><h2 id="Feature-representation"><a href="#Feature-representation" class="headerlink" title="Feature representation"></a>Feature representation</h2><h3 id="Individual-features"><a href="#Individual-features" class="headerlink" title="Individual features"></a>Individual features</h3><ul><li>Forr text features such as a query, one option is to convert the string into a tri-letter gram with 49, 292 dimensions</li><li>Categorical input is represented by a one-hot vector</li><li>There are usually millions of campaigns in a sponsered search system. one hot vector would significnatly increase the size of the model. One solution is to use a pair of compaign features as exemplified in the table (For example, only the top 10K cmpaigns with the highest numberof clicks)</li></ul><h2 id="Model-architecture"><a href="#Model-architecture" class="headerlink" title="Model architecture"></a>Model architecture</h2><p><img src="https://dos-tacos.github.io/images/syleeie/2019-07-21/deepcrossing.png" alt="image"></p><h3 id="Embedding-and-Stacking-layers"><a href="#Embedding-and-Stacking-layers" class="headerlink" title="Embedding and Stacking layers"></a>Embedding and Stacking layers</h3><ul><li>Embedding is applied per individual feature to transform the input features</li><li>The stacking layer is to concate them into one vector </li></ul><p><img src="https://raw.githubusercontent.com/HJSang/hjsang.github.io/main/medias/image/deep_cross1.png" alt="image"></p><h3 id="Residual-layer"><a href="#Residual-layer" class="headerlink" title="Residual layer"></a>Residual layer</h3><p><img src="https://raw.githubusercontent.com/HJSang/hjsang.github.io/main/medias/image/deep_cross2.png" alt="image"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Recommendation system </tag>
            
            <tag> CTR prediction </tag>
            
            <tag> Deep Crossing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Note for AutoRec: Autoencoders Meet Collaborative Filtering</title>
      <link href="2021/01/16/Note-for-AutoRec-Autoencoders-Meet-Collaborative-Filtering/"/>
      <url>2021/01/16/Note-for-AutoRec-Autoencoders-Meet-Collaborative-Filtering/</url>
      
        <content type="html"><![CDATA[<h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><ul><li>The problem this paper solves: rating-based collabrative filtering:<ul><li>m users and n iterms</li><li>Each user can be represented by a partially observed vector</li><li>Each item can be represented by a partially observed vector</li><li>The aim of CF is to project the rating matrix to a low-dimension latent space</li><li>We can consider User latent space or Item latent space, which leads to UserCF and Item CF</li></ul></li></ul><ul><li><p>User CF</p><ul><li>Motivation: <strong>similar people will have similar taste</strong></li><li>Limitation: the user number m grows faster and the history of users is very sparse</li></ul></li><li><p>Item CF</p><ul><li>Motivation: <strong>Recommend similar item</strong></li><li>For example, Netflix recommends similar movies.</li><li>Use Item CF most cases</li></ul></li></ul><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>The model architecture is:</p><p><img src="https://www.researchgate.net/profile/Lexing_Xie/publication/311491420/figure/fig1/AS:710737718689792@1546464485935/Item-based-AutoRec-model-We-use-plate-notation-to-indicate-that-there-are-n-copies-of.png" alt="image"></p><p>The model is: </p><p><img src="https://raw.githubusercontent.com/HJSang/hjsang.github.io/main/medias/image/auto_rec.png" alt="image"></p><p>The loss function is: </p><p><img src="https://raw.githubusercontent.com/HJSang/hjsang.github.io/main/medias/image/auto_rec2.png" alt="image"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://github.com/gtshs2/Autorec/blob/master/AutoRec.py">Implementation AutoRec</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Recommendation system </tag>
            
            <tag> CF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Note for Wide and Deep Learning for Recommendation Systems</title>
      <link href="2021/01/16/Note-for-Wide-and-Deep-Learning-for-Recommendation-Systems/"/>
      <url>2021/01/16/Note-for-Wide-and-Deep-Learning-for-Recommendation-Systems/</url>
      
        <content type="html"><![CDATA[<p><a href="https://arxiv.org/pdf/1606.07792.pdf">Paper Link</a></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li><p><strong>Problem Statement</strong>:</p><ul><li>Large-scale regression and classification probelms with sparse inputs. </li></ul></li><li><p>Wide &amp; Deep model for joinly training feed-forward neutral networks with embeddings and linear model with feature transformations for generic recommendation systems with sparse inuts.</p></li><li><p><strong>Memorization</strong>: memorize the results for some feature interactions through a wide set of cross-product features. It is effective and interpretable while requiring manually feature engineering. </p></li><li><p><strong>Generalization</strong>: With less feature engineering, deep neural networks can generalize better to unseen feature combinations through low-dimensional dense embeddings learned for the sparse features.</p></li></ul><h2 id="Wide-amp-Deep"><a href="#Wide-amp-Deep" class="headerlink" title="Wide &amp; Deep"></a>Wide &amp; Deep</h2><ul><li><p><strong>Setup</strong>: assume feature vector is X and label is Y.</p></li><li><p><strong>Wide Componen</strong>: the wide component is a linear model. The feature is  [X, phi(X)], where phi(X) is the cross-product transformation</p></li></ul><p><img src="https://miro.medium.com/max/2400/1*XHvOuICw2E9inCJJxIyKUg.png" alt="image"></p><ul><li><p><strong>Deep component</strong>: we input the feature vector X and map through embedding matrix and hidden layers.</p></li><li><p><strong>Joint Model</strong>: The joint model is<br><img src="https://miro.medium.com/max/700/1*c704nx973VSTAGhWnevIuA.png" alt="image"></p></li></ul><p><img src="https://miro.medium.com/max/690/1*pUzvrJijGioaxv8Xv71Wvw.png" alt="image"></p><p><img src="https://1.bp.blogspot.com/-Dw1mB9am1l8/V3MgtOzp3uI/AAAAAAAABGs/mP-3nZQCjWwdk6qCa5WraSpK8A7rSPj3ACLcB/s1600/image04.png" alt="image"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://deepctr-doc.readthedocs.io/en/latest/index.html">DeepCTR</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Recommendation system </tag>
            
            <tag> CTR prediction </tag>
            
            <tag> Wide &amp; Deep </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 1209: Remove All Adjacent Duplicates in String II</title>
      <link href="2021/01/04/Leetcode-1209-Remove-All-Adjacent-Duplicates-in-String-II/"/>
      <url>2021/01/04/Leetcode-1209-Remove-All-Adjacent-Duplicates-in-String-II/</url>
      
        <content type="html"><![CDATA[<p>Medium </p><p>Given a string s, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them causing the left and the right side of the deleted substring to concatenate together.</p><p>We repeatedly make k duplicate removals on s until we no longer can.</p><p>Return the final string after all such duplicate removals have been made.</p><p>It is guaranteed that the answer is unique.</p><p><strong>Example 1</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abcd&quot;, k &#x3D; 2</span><br><span class="line">Output: &quot;abcd&quot;</span><br><span class="line">Explanation: There&#39;s nothing to delete.</span><br></pre></td></tr></table></figure></p><p><strong>Example 2</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;deeedbbcccbdaa&quot;, k &#x3D; 3</span><br><span class="line">Output: &quot;aa&quot;</span><br><span class="line">Explanation:</span><br><span class="line">First delete &quot;eee&quot; and &quot;ccc&quot;, get &quot;ddbbbdaa&quot;</span><br><span class="line">Then delete &quot;bbb&quot;, get &quot;dddaa&quot;</span><br><span class="line">Finally delete &quot;ddd&quot;, get &quot;aa&quot;</span><br></pre></td></tr></table></figure></p><p><strong>Example 3</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;pbbcggttciiippooaais&quot;, k &#x3D; 2</span><br><span class="line">Output: &quot;ps&quot;</span><br></pre></td></tr></table></figure></p><p><strong>Constraints</strong>:</p><ul><li>1 &lt;= s.length &lt;= 10\^5</li><li>2 &lt;= k &lt;= 10\^4</li><li>s only contains lower case English letters</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                <span class="keyword">if</span> c == stack[-<span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">                    stack[-<span class="number">1</span>][<span class="number">1</span>] +=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> stack[-<span class="number">1</span>][<span class="number">1</span>] == k:</span><br><span class="line">                        stack.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.append([c,<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append([c,<span class="number">1</span>])</span><br><span class="line">        ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> stack:</span><br><span class="line">            ans += i[<span class="number">0</span>]*i[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 224: Basic Calculator</title>
      <link href="2021/01/04/Leetcode-224-Basic-Calculator/"/>
      <url>2021/01/04/Leetcode-224-Basic-Calculator/</url>
      
        <content type="html"><![CDATA[<p>Hard</p><p>Given a string s representing an expression, implement a basic calculator to evaluate it.</p><p><strong>Example 1</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;1 + 1&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p><p><strong>Example 2</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot; 2-1 + 2 &quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p><p><strong>Example 3</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;(1+(4+5+2)-3)+(6+8)&quot;</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure></p><p><strong>Constraints</strong>:</p><ul><li>1 &lt;= s.length &lt;= 3 * 105</li><li>s consists of digits, ‘+’, ‘-‘, ‘(‘, ‘)’, and ‘ ‘.</li><li>s represents a valid expression.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        res, num, stack, sign = <span class="number">0</span>,<span class="number">0</span>,[],<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                num = <span class="number">10</span>*num +<span class="built_in">int</span>(c)</span><br><span class="line">            <span class="keyword">elif</span> c==<span class="string">&quot;+&quot;</span>:</span><br><span class="line">                res += sign*num</span><br><span class="line">                num=<span class="number">0</span></span><br><span class="line">                sign=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> c==<span class="string">&quot;-&quot;</span>:</span><br><span class="line">                res += sign*num</span><br><span class="line">                num=<span class="number">0</span></span><br><span class="line">                sign=-<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> c==<span class="string">&quot;(&quot;</span>:</span><br><span class="line">                stack.append(res)</span><br><span class="line">                stack.append(sign)</span><br><span class="line">                res=<span class="number">0</span></span><br><span class="line">                sign=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> c==<span class="string">&quot;)&quot;</span>:</span><br><span class="line">                prev_sign = stack.pop()</span><br><span class="line">                prev_res = stack.pop()</span><br><span class="line">                res+=sign*num</span><br><span class="line">                res = prev_res + prev_sign*(res)</span><br><span class="line">                num=<span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> res+sign*num</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 227: Basic Calculator II</title>
      <link href="2021/01/04/Leetcode-227-Basic-Calculator-II/"/>
      <url>2021/01/04/Leetcode-227-Basic-Calculator-II/</url>
      
        <content type="html"><![CDATA[<p>Medium</p><p>Given a string s which represents an expression, evaluate this expression and return its value.</p><p>The integer division should truncate toward zero.</p><p><strong>Example 1</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;3+2*2&quot;</span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure></p><p><strong>Example 2</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot; 3&#x2F;2 &quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p><p><strong>Example 3</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot; 3+5 &#x2F; 2 &quot;</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure></p><p><strong>Constraints</strong>:</p><ul><li>1 &lt;= s.length &lt;= 3 * 105</li><li>s consists of integers and operators (‘+’, ‘-‘, ‘*‘, ‘/‘) separated by some number of spaces.</li><li>s represents a valid expression.</li><li>All the integers in the expression are non-negative integers in the range [0, 231 - 1].</li><li>The answer is guaranteed to fit in a 32-bit integer.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># Stack</span></span><br><span class="line">        <span class="comment"># c in &#123;digit, +, -, *, /&#125;</span></span><br><span class="line">        <span class="comment"># *, / have higher priority than +, -</span></span><br><span class="line">        <span class="comment"># if the operator is * or /, perform imediately</span></span><br><span class="line">        stack = []</span><br><span class="line">        sign = <span class="string">&#x27;+&#x27;</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i,c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                num = <span class="number">10</span>*num + <span class="built_in">int</span>(c)</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> [<span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;*&#x27;</span>] <span class="keyword">or</span> i==n-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> sign == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    stack.append(num)</span><br><span class="line">                <span class="keyword">if</span> sign == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    stack.append(-num)</span><br><span class="line">                <span class="keyword">if</span> sign == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    prev = stack.pop()</span><br><span class="line">                    stack.append(prev*num)</span><br><span class="line">                <span class="keyword">if</span> sign == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    prev = stack.pop()</span><br><span class="line">                    <span class="keyword">if</span> prev&gt;<span class="number">0</span>:</span><br><span class="line">                        stack.append(prev//num)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        stack.append(-(-prev//num))</span><br><span class="line">                sign = c</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(stack)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 1249: Minimum Remove to Make Valid Parentheses</title>
      <link href="2021/01/04/Leetcode-1249-Minimum-Remove-to-Make-Valid-Parentheses/"/>
      <url>2021/01/04/Leetcode-1249-Minimum-Remove-to-Make-Valid-Parentheses/</url>
      
        <content type="html"><![CDATA[<p>Medium</p><p>Given a string s of ‘(‘ , ‘)’ and lowercase English characters.</p><p>Your task is to remove the minimum number of parentheses ( ‘(‘ or ‘)’, in any positions ) so that the resulting parentheses string is valid and return any valid string.</p><p>Formally, a parentheses string is valid if and only if:</p><ul><li>It is the empty string, contains only lowercase characters, or</li><li>It can be written as AB (A concatenated with B), where A and B are valid strings, or</li><li>It can be written as (A), where A is a valid string.</li></ul><p><strong>Example 1</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;lee(t(c)o)de)&quot;</span><br><span class="line">Output: &quot;lee(t(c)o)de&quot;</span><br><span class="line">Explanation: &quot;lee(t(co)de)&quot; , &quot;lee(t(c)ode)&quot; would also be accepted.</span><br></pre></td></tr></table></figure></p><p><strong>Example 2</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;a)b(c)d&quot;</span><br><span class="line">Output: &quot;ab(c)d&quot;</span><br></pre></td></tr></table></figure></p><p><strong>Example 3</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;))((&quot;</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: An empty string is also valid.</span><br></pre></td></tr></table></figure></p><p><strong>Example 4</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;(a(b(c)d)&quot;</span><br><span class="line">Output: &quot;a(b(c)d)&quot;</span><br></pre></td></tr></table></figure></p><p><strong>Constraints</strong>:</p><ul><li>1 &lt;= s.length &lt;= 10^5</li><li>s[i] is one of  ‘(‘ , ‘)’ and lowercase English letters.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minRemoveToMakeValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        remove = []</span><br><span class="line">        <span class="keyword">for</span> index, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> val == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                stack.append(index)</span><br><span class="line">            <span class="keyword">elif</span> val == <span class="string">&quot;)&quot;</span> <span class="keyword">and</span> stack:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">elif</span> val == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                remove.append(index)</span><br><span class="line"></span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        ind = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(s)))</span><br><span class="line">        ind = [i <span class="keyword">for</span> i <span class="keyword">in</span> ind <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> remove+stack]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> ind:</span><br><span class="line">            res += s[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 394: Decode String</title>
      <link href="2021/01/04/Leetcode-394-Decode-String/"/>
      <url>2021/01/04/Leetcode-394-Decode-String/</url>
      
        <content type="html"><![CDATA[<p>Medium </p><p>Given an encoded string, return its decoded string.</p><p>The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.</p><p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p><p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4].</p><p><strong>Example 1</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;3[a]2[bc]&quot;</span><br><span class="line">Output: &quot;aaabcbc&quot;</span><br></pre></td></tr></table></figure></p><p><strong>Example 2</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;3[a2[c]]&quot;</span><br><span class="line">Output: &quot;accaccacc&quot;</span><br></pre></td></tr></table></figure></p><p><strong>Example 3</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;2[abc]3[cd]ef&quot;</span><br><span class="line">Output: &quot;abcabccdcdcdef&quot;</span><br></pre></td></tr></table></figure></p><p><strong>Example 4</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abc3[cd]xyz&quot;</span><br><span class="line">Output: &quot;abccdcdcdxyz&quot;</span><br></pre></td></tr></table></figure></p><p><strong>Constraints</strong>:</p><ul><li>1 &lt;= s.length &lt;= 30</li><li>s consists of lowercase English letters, digits, and square brackets ‘[]’.</li><li>s is guaranteed to be a valid input.</li><li>All the integers in s are in the range [1, 300].</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="comment"># Stack</span></span><br><span class="line">        <span class="comment"># char is one of &#123;digit, alphabet, [, ]&#125;</span></span><br><span class="line">        <span class="comment"># to understand operators for each case</span></span><br><span class="line">        stack = []</span><br><span class="line">        ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        cur_string = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> char.isdigit():</span><br><span class="line">                num = <span class="number">10</span>*num + <span class="built_in">int</span>(char)</span><br><span class="line">            <span class="keyword">if</span> char.isalpha():</span><br><span class="line">                cur_string += char</span><br><span class="line">            <span class="keyword">if</span> char == <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                stack.append((num,cur_string))</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                cur_string = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> char == <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                k, prev_string = stack.pop()</span><br><span class="line">                cur_string = prev_string + cur_string * k</span><br><span class="line">        <span class="keyword">return</span> cur_string</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 42: Trapping Rain Water</title>
      <link href="2021/01/04/Leetcode-42-Trapping-Rain-Water/"/>
      <url>2021/01/04/Leetcode-42-Trapping-Rain-Water/</url>
      
        <content type="html"><![CDATA[<p>Hard</p><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.</p><p><strong>Example 1</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" alt="image"></p><p>Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]<br>Output: 6<br>Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.</p><p><strong> Two Pointers</strong>:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># The unit can trap water if its left and right are both higher than the bar.</span></span><br><span class="line">        <span class="comment"># The volume of the water is determined by the maximum values of its left and right</span></span><br><span class="line">        n = <span class="built_in">len</span>(height)</span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftM, rightM = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        l,r=<span class="number">0</span>,n-<span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;r:</span><br><span class="line">            leftM = <span class="built_in">max</span>(height[l], leftM)</span><br><span class="line">            rightM = <span class="built_in">max</span>(height[r], rightM)</span><br><span class="line">            <span class="keyword">if</span> leftM &lt; rightM:</span><br><span class="line">                ans += (leftM - height[l])</span><br><span class="line">                l +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += (rightM - height[r])</span><br><span class="line">                r -=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p><p><strong> Stack </strong>:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># Stack</span></span><br><span class="line">        <span class="comment"># Keep a stack and iterate over the array</span></span><br><span class="line">        <span class="comment"># Add the index to the stack if the bar is smaller or equal to the bar at top of stack</span></span><br><span class="line">        <span class="comment"># If we found a bar longer than the top: [4,1] and 5</span></span><br><span class="line">        <span class="comment"># Then we know the water of &quot;1&quot; is 3.</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(height)</span><br><span class="line">        stack = []</span><br><span class="line">        current = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> current &lt; n:</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> height[current] &gt; height[stack[-<span class="number">1</span>]]:</span><br><span class="line">                top = stack[-<span class="number">1</span>]</span><br><span class="line">                stack.pop()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                distance = current - stack[-<span class="number">1</span>] -<span class="number">1</span></span><br><span class="line">                bounded_height = <span class="built_in">min</span>(height[current],height[stack[-<span class="number">1</span>]]) - height[top]</span><br><span class="line">                ans += distance * bounded_height</span><br><span class="line"></span><br><span class="line">            stack.append(current)</span><br><span class="line">            current +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Stack </tag>
            
            <tag> Two pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas: from Zero to Hero</title>
      <link href="2021/01/02/Pandas-from-Zero-to-Hero/"/>
      <url>2021/01/02/Pandas-from-Zero-to-Hero/</url>
      
        <content type="html"><![CDATA[<p>This article is also shown in <a href="https://sanghj0923.medium.com/pandas-from-zero-to-hero-4322b333442c">medium</a>.  The treading takes around 5 minutes.</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In this article, we will learn the most common functions in Pandas. You should be able to use Pandas for:  loading &amp; saving data frames, select subsets, data manipulation and some other common functions.</p><h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><p>Pandas provides lots of I/O functions to handle different data formats. Their function names share the same patterns: reading functions are all “read_{data format}” and writing functions are all “to_{data format}”. For example, “read_pickle” is used to load pickled object from file and “to_pickle” is used to serialize object to file.  In this article, we focus on CSV files.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import pandas</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># read csv file</span></span><br><span class="line">csv_data = pd.read_csv(filepath_or_buffer=<span class="string">&#x27;data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># save output to csv</span></span><br><span class="line">csv_data.to_csv(path_or_buf=<span class="string">&#x27;csv_data.csv&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="Select-Subset"><a href="#Select-Subset" class="headerlink" title="Select Subset"></a>Select Subset</h2><p>We can use “.loc” and “.iloc” to select subsets from the original dataframe. Prefer “.iloc” if we want to use the positions in the dataframe. Otherwise, we can use “.loc”.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import pandas</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># Create dataframe</span></span><br><span class="line">gender = [<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;F&#x27;</span>]</span><br><span class="line">company = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&quot;age&quot;</span>: np.random.randint(<span class="number">10</span>,<span class="number">60</span>,<span class="number">100</span>),</span><br><span class="line">                  <span class="string">&quot;gender&quot;</span>: [gender[i] <span class="keyword">for</span> i <span class="keyword">in</span> np.random.randint(<span class="number">0</span>,<span class="number">2</span>,<span class="number">100</span>)],</span><br><span class="line">                   <span class="string">&quot;company&quot;</span>: [company[i] <span class="keyword">for</span> i <span class="keyword">in</span> np.random.randint(<span class="number">0</span>,<span class="number">3</span>,<span class="number">100</span>)],</span><br><span class="line">                  <span class="string">&quot;salary&quot;</span>: np.random.randint(<span class="number">100</span>,<span class="number">1000</span>,<span class="number">100</span>)&#125;)</span><br><span class="line"><span class="comment"># df looks like:</span></span><br><span class="line"><span class="comment">#   age gender  company salary</span></span><br><span class="line"><span class="comment"># 0 18  F A 132</span></span><br><span class="line"><span class="comment"># 1 41  F B 333</span></span><br><span class="line"><span class="comment"># 2 25  F A 981</span></span><br><span class="line"><span class="comment"># 3 26  M C 686</span></span><br><span class="line"><span class="comment"># 4 48  M B 530</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Select row [0,5] with all columns</span></span><br><span class="line">df.iloc[[<span class="number">0</span>,<span class="number">5</span>],:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Select row [0,5] with columns [1,2]</span></span><br><span class="line">df.iloc[[<span class="number">0</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Select gender == &#x27;F&#x27;</span></span><br><span class="line">df.loc[df[<span class="string">&#x27;gender&#x27;</span>]==<span class="string">&#x27;F&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Select gender == &#x27;F&#x27; and company in [&#x27;A&#x27;, &#x27;B&#x27;]</span></span><br><span class="line">df.loc[(df[<span class="string">&#x27;gender&#x27;</span>]==<span class="string">&#x27;F&#x27;</span>) &amp; (df[<span class="string">&#x27;company&#x27;</span>].isin([<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>]))]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Select people with age &gt; 30 and salary &gt; 700 and show their salary</span></span><br><span class="line"></span><br><span class="line">df.loc[(df[<span class="string">&#x27;age&#x27;</span>]&gt;<span class="number">30</span>) &amp; (df[<span class="string">&#x27;salary&#x27;</span>]&gt;<span class="number">700</span>),<span class="string">&#x27;salary&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="Manipulation"><a href="#Manipulation" class="headerlink" title="Manipulation"></a>Manipulation</h2><p>Pandas can perform most common data manipulations: Merge, GroupBy and Reshape.</p><h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><p>For “Merge” operation, there are:</p><ul><li>“Left” merge: use only keys from left frame</li><li>“Right” merge: use only keys from right frame</li><li>“Outer” merge: use union of keys from both frames</li><li>“Inner” merge: use intersection of keys from both frames</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create two dataframes</span></span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>:[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>], <span class="string">&#x27;B&#x27;</span>:[<span class="number">11</span>,<span class="number">12</span>]&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>:[<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>], <span class="string">&#x27;C&#x27;</span>:[<span class="number">12</span>,<span class="number">13</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># left join</span></span><br><span class="line">df1.merge(df2,how=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line"><span class="comment">#   A  B  C</span></span><br><span class="line"><span class="comment">#   1 11  NaN</span></span><br><span class="line"><span class="comment">#   2 12  12.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># right join</span></span><br><span class="line">df1.merge(df2,how=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line"><span class="comment">#   A  B     C</span></span><br><span class="line"><span class="comment">#   2 12.0  12</span></span><br><span class="line"><span class="comment">#   3 NaN   13</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># inner join</span></span><br><span class="line">df1.merge(df2,how=<span class="string">&#x27;inner&#x27;</span>)</span><br><span class="line"><span class="comment"># A  B   C</span></span><br><span class="line"><span class="comment"># 2  12  12</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># outer join</span></span><br><span class="line">df1.merge(df2,how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line"><span class="comment"># A B     C</span></span><br><span class="line"><span class="comment"># 1 11.0  NaN</span></span><br><span class="line"><span class="comment"># 2 12.0  12.0</span></span><br><span class="line"><span class="comment"># 3 NaN   13.0</span></span><br></pre></td></tr></table></figure><h3 id="GroupBy"><a href="#GroupBy" class="headerlink" title="GroupBy"></a>GroupBy</h3><p>GroupBy operator is to group dataframe by some column(s) and then perform aggregation.<br>Operators following by GroupBy:</p><ul><li>Agg: support multiple default aggregations {min, max, sum, mean, median, std, var, count}</li><li>Transform: perform aggregation functions on each group and return a DataFrame having the same indexes as the original object filled with the transformed values</li><li>Apply: apply the flexible functions to each group</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create dataframe</span></span><br><span class="line">np.random.seed(<span class="number">2021</span>)</span><br><span class="line">company = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>]</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&quot;company&quot;</span>: [company[i] <span class="keyword">for</span> i <span class="keyword">in</span> np.random.randint(<span class="number">0</span>,<span class="number">2</span>,<span class="number">10</span>)],</span><br><span class="line">                  <span class="string">&quot;salary&quot;</span>: np.random.randint(<span class="number">100</span>,<span class="number">1000</span>,<span class="number">10</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># groupby object</span></span><br><span class="line">df.groupby(by=<span class="string">&#x27;company&#x27;</span>)</span><br><span class="line"><span class="comment"># &lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x7f33aef16630&gt;</span></span><br><span class="line"><span class="comment"># It is a memory address. In order to check the data after groupby, we can use list.</span></span><br><span class="line"><span class="built_in">list</span>(df.groupby(by=<span class="string">&#x27;company&#x27;</span>))</span><br><span class="line"><span class="comment"># [(&#x27;A&#x27;,   company  salary</span></span><br><span class="line"><span class="comment">#   0       A     728</span></span><br><span class="line"><span class="comment">#   1       A     345</span></span><br><span class="line"><span class="comment">#   4       A     553</span></span><br><span class="line"><span class="comment">#   6       A     515</span></span><br><span class="line"><span class="comment">#   7       A     289), (&#x27;B&#x27;,   company  salary</span></span><br><span class="line"><span class="comment">#   2       B     915</span></span><br><span class="line"><span class="comment">#   3       B     146</span></span><br><span class="line"><span class="comment">#   5       B     483</span></span><br><span class="line"><span class="comment">#   8       B     452</span></span><br><span class="line"><span class="comment">#   9       B     461)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># agg: minimum salary per company</span></span><br><span class="line">df.groupby(by=<span class="string">&#x27;company&#x27;</span>).agg(&#123;<span class="string">&#x27;salary&#x27;</span>:<span class="string">&#x27;min&#x27;</span>&#125;)</span><br><span class="line"><span class="comment">#           salary</span></span><br><span class="line"><span class="comment"># company</span></span><br><span class="line"><span class="comment"># A         202</span></span><br><span class="line"><span class="comment"># B         170</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># transform:</span></span><br><span class="line">df.groupby(by=<span class="string">&#x27;company&#x27;</span>)[<span class="string">&#x27;salary&#x27;</span>].transform(<span class="string">&#x27;min&#x27;</span>)</span><br><span class="line"><span class="comment"># 0    202</span></span><br><span class="line"><span class="comment"># 1    170</span></span><br><span class="line"><span class="comment"># 2    170</span></span><br><span class="line"><span class="comment"># 3    202</span></span><br><span class="line"><span class="comment"># 4    170</span></span><br><span class="line"><span class="comment"># 5    202</span></span><br><span class="line"><span class="comment"># 6    202</span></span><br><span class="line"><span class="comment"># 7    202</span></span><br><span class="line"><span class="comment"># 8    170</span></span><br><span class="line"><span class="comment"># 9    202</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply_min</span>(<span class="params">x</span>):</span></span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">min</span>(x[<span class="string">&#x27;salary&#x27;</span>])</span><br><span class="line">df.groupby(by=<span class="string">&#x27;company&#x27;</span>).apply(apply_min)</span><br><span class="line"></span><br><span class="line"><span class="comment"># company</span></span><br><span class="line"><span class="comment"># A    202</span></span><br><span class="line"><span class="comment"># B    170</span></span><br></pre></td></tr></table></figure><h3 id="Reshape"><a href="#Reshape" class="headerlink" title="Reshape"></a>Reshape</h3><ul><li>If you want to gather columns into rows: melt.</li><li>If you want to append rows/columns: concat</li><li>If you want to spread rows into columns: pivot, pivot_table</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create two dataframes</span></span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>:[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>], <span class="string">&#x27;B&#x27;</span>:[<span class="number">11</span>,<span class="number">12</span>]&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>:[<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>], <span class="string">&#x27;B&#x27;</span>:[<span class="number">12</span>,<span class="number">13</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># append rows</span></span><br><span class="line">pd.concat([df1,df2])</span><br><span class="line"><span class="comment">#   A B</span></span><br><span class="line"><span class="comment"># 0 1 11</span></span><br><span class="line"><span class="comment"># 1 2 12</span></span><br><span class="line"><span class="comment"># 0 2 12</span></span><br><span class="line"><span class="comment"># 1 3 13</span></span><br><span class="line"></span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>:[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>], <span class="string">&#x27;B&#x27;</span>:[<span class="number">11</span>,<span class="number">12</span>]&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">&#x27;C&#x27;</span>:[<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>], <span class="string">&#x27;D&#x27;</span>:[<span class="number">12</span>,<span class="number">13</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># append columns</span></span><br><span class="line">pd.concat([df1,df2],axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#   A  B  C  D</span></span><br><span class="line"><span class="comment"># 0 1 11  2 12</span></span><br><span class="line"><span class="comment"># 1 2 12  3 13</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># melt</span></span><br><span class="line">pd.melt(df1)</span><br><span class="line"><span class="comment">#   variable  value</span></span><br><span class="line"><span class="comment"># 0    A      1</span></span><br><span class="line"><span class="comment"># 1    A      2</span></span><br><span class="line"><span class="comment"># 2    B      11</span></span><br><span class="line"><span class="comment"># 3    B      12</span></span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>], <span class="string">&#x27;B&#x27;</span>:[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],<span class="string">&#x27;C&#x27;</span>:[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]&#125;)</span><br><span class="line">df.pivot_table(index=<span class="string">&#x27;A&#x27;</span>,columns=<span class="string">&#x27;B&#x27;</span>,values=<span class="string">&#x27;C&#x27;</span>,aggfunc=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line"><span class="comment"># B 1 2</span></span><br><span class="line"><span class="comment"># A</span></span><br><span class="line"><span class="comment"># 1 0.0 1.0</span></span><br><span class="line"><span class="comment"># 2 1.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Other-Common-Functions"><a href="#Other-Common-Functions" class="headerlink" title="Other Common Functions"></a>Other Common Functions</h2><ul><li>df.drop_duplicates(): remove duplicate rows</li><li>df.head(n): select first n rows</li><li>df.tail(n): select last n rows</li><li>df.sample(n): randomly select n rows</li><li>df.sort_values(by=’mpg’, ascending=False): order rows by values of a column</li><li>df.rename(‘columns’={‘y’:’year’}, inplace=True): rename the column ‘y’ to ‘year’</li><li>df.sort_index(): sort the index of a DataFrame</li><li>df.reset_index(): reset the index to row numbers &amp; move the index to columns</li><li>df.drop(columns=[‘length’, ‘height’]): drop columns</li><li>df[’year’].value_counts(normalize=True, sort=True, ascending=False, bins=None, dropna=True): return the distribution of unique values</li><li>df.dropna(axis=0, how=’any’, inplace=True): remove rows with missing values</li><li>df.fillna(0): Replace all NaN elements with 0s.</li><li>pd.cut(x=df[‘height’], bins=3, labels=[“bad”, “medium”, “good”]): Bin values into discrete intervals.</li></ul><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Pandas is a useful tool in python, which can perform I/O, subsetting, and manipulation. By reading this article, you are able to perform most data processings using DataFrame. </p>]]></content>
      
      
      
        <tags>
            
            <tag> pandas </tag>
            
            <tag> data science </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 236: Lowest Common Ancestor of a Binary Tree</title>
      <link href="2020/12/26/Leetcode-236-Lowest-Common-Ancestor-of-a-Binary-Tree/"/>
      <url>2020/12/26/Leetcode-236-Lowest-Common-Ancestor-of-a-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<p>Medium</p><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p><p><strong>Example 1</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       3</span><br><span class="line">      &#x2F; \</span><br><span class="line">    5     1</span><br><span class="line">  &#x2F;  \   &#x2F; \</span><br><span class="line">6     2 0   8</span><br><span class="line">     &#x2F; \</span><br><span class="line">    7   4</span><br></pre></td></tr></table></figure><br>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>Output: 3<br>Explanation: The LCA of nodes 5 and 1 is 3.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reading Note for  Wide and Deep Learning for Recommender Systems</title>
      <link href="2020/12/25/Wide-and-Deep-Learning-for-Recommender-Systems/"/>
      <url>2020/12/25/Wide-and-Deep-Learning-for-Recommender-Systems/</url>
      
        <content type="html"><![CDATA[<p><strong>Paper link</strong>: <a href="https://arxiv.org/pdf/1606.07792.pdf">Wide &amp; Deep Learning for Recommender Systems</a></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li>The input features are sparse</li><li>Memorization of feature interactions through a wide set of <strong>cross-product</strong> feature transformations are effective and interpretable. However, generalization requires more feature engineering effort.</li><li>Deep neural networks can generalize better to unseen feature combinations through <strong>low-dimensional dense embeddings</strong> learned from the sparse features.</li><li>Therefore, this paper combines two: jointly train wide linear models and deep neural networks.</li></ul><h2 id="Model-Architecture"><a href="#Model-Architecture" class="headerlink" title="Model Architecture"></a>Model Architecture</h2><p><img src="https://1.bp.blogspot.com/-Dw1mB9am1l8/V3MgtOzp3uI/AAAAAAAABGs/mP-3nZQCjWwdk6qCa5WraSpK8A7rSPj3ACLcB/s1600/image04.png" alt="Image"></p><h3 id="Wide-Component"><a href="#Wide-Component" class="headerlink" title="Wide Component"></a>Wide Component</h3><ul><li>Assume y is the prediction and <strong>x</strong> is a vector of d features. The wide component is a generalized linear model of the form <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y &#x3D; w^T x + b</span><br></pre></td></tr></table></figure></li><li>One of the most important transformations is the <strong>cross-product</strong> transformation. For binary features, a cross-product transformation “AND( gender=male, language=en)” is 1 only if gender is male and language is en.</li></ul><p><img src="https://miro.medium.com/max/700/1*XHvOuICw2E9inCJJxIyKUg.png" alt="image"></p><h3 id="Deep-Componennt"><a href="#Deep-Componennt" class="headerlink" title="Deep Componennt"></a>Deep Componennt</h3><ul><li>Each of these sparse high-dimensional categorical features are first converted into a low-dimensional and dense real-valued vector</li><li>Those low-dimensional vectors are then fed into a hidden layers and a neural network</li></ul><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p><img src="https://raw.githubusercontent.com/HJSang/hjsang.github.io/main/medias/image/wide_deep_model.png" alt="image"></p>]]></content>
      
      
      
        <tags>
            
            <tag> paper </tag>
            
            <tag> recommender system </tag>
            
            <tag> deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 105: Construct Binary Tree from Preorder and InorderTraversal</title>
      <link href="2020/12/25/Leetcode-105-Construct-Binary-Tree-from-Preorder-and-InorderTraversal/"/>
      <url>2020/12/25/Leetcode-105-Construct-Binary-Tree-from-Preorder-and-InorderTraversal/</url>
      
        <content type="html"><![CDATA[<p>Medium</p><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p><p>Note:<br>You may assume that duplicates do not exist in the tree.</p><p>For example, given</p><p>preorder = [3,9,20,15,7]<br>inorder = [9,3,15,20,7]<br>Return the following binary tree:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9   20</span><br><span class="line">   &#x2F; \</span><br><span class="line">  15  7</span><br></pre></td></tr></table></figure><p><strong>Solution</strong>:</p><ul><li>Please noet that: preorder =[root, root.left, root.right] and inorder = [root.left, root, root.right]. </li><li>root.left and root.right can be none</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: List[<span class="built_in">int</span>], inorder: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> inorder:</span><br><span class="line">            root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">            ind = inorder.index(preorder[<span class="number">0</span>])</span><br><span class="line">            preorder.pop(<span class="number">0</span>)</span><br><span class="line">            root.left = self.buildTree(preorder,inorder[:ind])</span><br><span class="line">            root.right = self.buildTree(preorder,inorder[ind+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: List[<span class="built_in">int</span>], inorder: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># empty tree</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder: <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># Create ierator for preorder and inorder</span></span><br><span class="line">        preorder_iter, inorder_iter = <span class="built_in">iter</span>(preorder), <span class="built_in">iter</span>(inorder)</span><br><span class="line">        <span class="comment"># Initial root as the first element in preorder and initialize the current inorder val</span></span><br><span class="line">        root, curr_inorder_val = TreeNode(<span class="built_in">next</span>(preorder_iter)), <span class="built_in">next</span>(inorder_iter)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># stack is used to track left trees</span></span><br><span class="line">        <span class="comment"># build_right_tree is a flag to indicate if it is the time to build the right tree</span></span><br><span class="line">        stack, node, build_right_tree = [root], root, <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>].val == curr_inorder_val:</span><br><span class="line">                    node = stack.pop() <span class="comment"># now it is the root node, and onto building its right tree.</span></span><br><span class="line">                    curr_inorder_val = <span class="built_in">next</span>(inorder_iter)</span><br><span class="line">                    build_right_tree = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> build_right_tree:</span><br><span class="line">                        node.right = TreeNode(<span class="built_in">next</span>(preorder_iter))</span><br><span class="line">                        node = node.right</span><br><span class="line">                        build_right_tree = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        node.left = TreeNode(<span class="built_in">next</span>(preorder_iter))</span><br><span class="line">                        node = node.left</span><br><span class="line"></span><br><span class="line">                    stack.append(node)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Traversal </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 124: Binary Tree Maximum Path Sum</title>
      <link href="2020/12/25/Leetcode-124-Binary-Tree-Maximum-Path-Sum/"/>
      <url>2020/12/25/Leetcode-124-Binary-Tree-Maximum-Path-Sum/</url>
      
        <content type="html"><![CDATA[<p>Hard</p><p>Given a non-empty binary tree, find the maximum path sum.</p><p>For this problem, a path is defined as any node sequence from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.</p><p><strong>Example 1</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   3</span><br></pre></td></tr></table></figure><br><strong>Input</strong>: root = [1,2,3]<br><strong>Output</strong>: 6</p><p><strong>Constraints</strong>:</p><ul><li>The number of nodes in the tree is in the range [0, 3 * 10^4]</li><li>-1000 &lt;= Node.val &lt;= 1000</li></ul><p><strong>Solution</strong>:</p><ul><li>Get the inorder tree traversal: Recursive or Iterative way </li><li><p>Find the maximum summation of sub-array</p><ul><li>DP: get the maximum summation of the subarray ending with the curent element </li><li>dp[i+1] = max(dp[i],0) + nums[i+1]</li></ul></li><li><p>For this problem, we can use the similar idea. Traversal the tree and max value is the max(lef, right, left+node.val+right)</p></li><li>the DP idea: the maximum summation of path values starting or ending with the node: max(node.val + max(left,right),0)</li></ul><p><strong>Recursive Inorder code</strong>:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">maxend</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left = maxend(node.left)</span><br><span class="line">            right = maxend(node.right)</span><br><span class="line">            self.<span class="built_in">max</span> = <span class="built_in">max</span>(self.<span class="built_in">max</span>, left + node.val + right)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(node.val + <span class="built_in">max</span>(left, right), <span class="number">0</span>)</span><br><span class="line">        self.<span class="built_in">max</span> = -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        maxend(root)</span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">max</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Binary Tree </tag>
            
            <tag> Tree Traversal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 297: Serialize and Deserialize Binary Tree</title>
      <link href="2020/12/24/Leetcode-297-Serialize-and-Deserialize-Binary-Tree/"/>
      <url>2020/12/24/Leetcode-297-Serialize-and-Deserialize-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<p>Hard</p><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p><p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p><p>Clarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p><p><strong>Example 1</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   1</span><br><span class="line"> &#x2F;  \</span><br><span class="line">2    3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br></pre></td></tr></table></figure><br>Input: root = [1,2,3,null,null,4,5]<br>Output: [1,2,3,null,null,4,5]</p><p><strong>Idea</strong>:</p><ul><li>We need to traversal the tree. Hence, consider BFS or DFS</li><li>We need to recustruct the tree from the serialized string. Hence, we need two key information: separating char and tree structure.</li><li>Given a string, we can split them by any special char, saying ‘#’.</li><li>For the tree structure, we need to know: left and right nodes. Hence, we need the order information.</li></ul><p><strong>BFS python code</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Encodes a tree to a single string.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        res = []</span><br><span class="line">        curNode = [root]</span><br><span class="line">        <span class="keyword">while</span> curNode:</span><br><span class="line">            nextNode = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> curNode:</span><br><span class="line">                res.append(<span class="built_in">str</span>(node.val) <span class="keyword">if</span> node <span class="keyword">else</span> <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> node:</span><br><span class="line">                    nextNode.append(node.left)</span><br><span class="line">                    nextNode.append(node.right)</span><br><span class="line">            curNode = nextNode</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;.&#x27;</span>.join(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        res = data.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        ind = <span class="number">1</span></span><br><span class="line">        head = TreeNode(<span class="built_in">int</span>(res[<span class="number">0</span>]))</span><br><span class="line">        curNode = [head]</span><br><span class="line">        <span class="keyword">while</span> curNode:</span><br><span class="line">            nextNode = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> curNode:</span><br><span class="line">                <span class="keyword">if</span> res[ind]!=<span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                    nd=TreeNode(<span class="built_in">int</span>(res[ind]))</span><br><span class="line">                    nextNode.append(nd)</span><br><span class="line">                    node.left = nd</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node.left = <span class="literal">None</span></span><br><span class="line">                ind +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> res[ind] == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                    node.right = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nd = TreeNode(<span class="built_in">int</span>(res[ind]))</span><br><span class="line">                    nextNode.append(nd)</span><br><span class="line">                    node.right = nd</span><br><span class="line">                ind +=<span class="number">1</span></span><br><span class="line">            curNode = nextNode</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p><strong> recursive DFS python code </strong>:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Encodes a tree to a single string.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">rserialize</span>(<span class="params">root,string</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                string += <span class="string">&#x27;#.&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                string += <span class="built_in">str</span>(root.val) + <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                string = rserialize(root.left, string)</span><br><span class="line">                string = rserialize(root.right, string)</span><br><span class="line">            <span class="keyword">return</span> string</span><br><span class="line">        <span class="keyword">return</span> rserialize(root, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">rdeserialize</span>(<span class="params">l</span>):</span></span><br><span class="line">            <span class="keyword">if</span> l[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                l.popleft()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            root = TreeNode(<span class="built_in">int</span>(l[<span class="number">0</span>]))</span><br><span class="line">            l.popleft()</span><br><span class="line">            root.left = rdeserialize(l)</span><br><span class="line">            root.right = rdeserialize(l)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        dlist = collections.deque(data.split(<span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">        root = rdeserialize(dlist)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reading Note: Improving Web Search Ranking by Incorporating User Behavior Information</title>
      <link href="2020/12/23/Reading-Note-Improving-Web-Search-Ranking-by-Incorporating-User-Behavior-Information/"/>
      <url>2020/12/23/Reading-Note-Improving-Web-Search-Ranking-by-Incorporating-User-Behavior-Information/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p> This paper explores whether implicit feedback can be helpful in realistic environments, where user feedback can be noisy and a web search engine already uses hundreds of features and is heavily tuned.</p><p> <strong>Contributions</strong>:</p><ul><li>Analysis of alternatives for incoporating user behavior into web search ranking</li><li>An application of a robust implicit feedback model</li><li>A large scale evaluation</li></ul><h2 id="Incorporating-Implicit-Feedback"><a href="#Incorporating-Implicit-Feedback" class="headerlink" title="Incorporating Implicit Feedback"></a>Incorporating Implicit Feedback</h2><ul><li><p><strong>Treating implicit feedback as independent evidence for ranking results</strong>:</p><ul><li>Re-rank the results obtained by a web search engine </li><li>Each result is assigned a score according to expected relevance/user satisfaction</li><li>For a given query <strong>q</strong>, the implicit score $IS_d$ is computed for each result $d$ from available user interaction features</li><li>The implicit score results in the implicit rank $I_d$ for each result</li><li>The original score rank is $O_d$</li><li>We compute the merged score: $S_M(d)= w_I \frac{1}{I_d+1}+\frac{1}{O_d+1}$ if implicit feedback exists for $d$.</li><li>Otherwise, $S_M(d) = \frac{1}{O_d}$</li></ul></li><li><p><strong>Ranking with implicit feedback features</strong>:</p><ul><li>Incorporate implicit feedback features directly as features for the ranking algorithm.</li><li>This model requires a ranking algorithm to be robust to missing values: more than 50% of queries are unique( without previous implicit feedback)</li><li>Use a 2-layer implementation of RankNet in order to model non-linear relationships between features.</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Web Search </tag>
            
            <tag> Implicit relevance feedback </tag>
            
            <tag> Web search ranking </tag>
            
            <tag> Paper reading notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 199: Binary Tree Right Side View</title>
      <link href="2020/12/23/Leetcode-199-Binary-Tree-Right-Side-View/"/>
      <url>2020/12/23/Leetcode-199-Binary-Tree-Right-Side-View/</url>
      
        <content type="html"><![CDATA[<p>Medium</p><p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p><p><strong>Example</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,null,5,null,4]</span><br><span class="line">Output: [1, 3, 4]</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure></p><p>When you need to search some values from the tree, please consider the tree traversal methods: BFS and DFS. For this specific problem, we need to find the most right elements at each level. Therefore, we need to find the level information and save all elements from the same level. It seems that BFS is easy to use. In most cases, dfs also performs the similar function of BFS in a different traversal trace. </p><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>Breath-First-Search (BFS): </p><ul><li>Initial current node list: curNode = [root]</li><li>while curNode is not empty:<ul><li>nextNode = [j for i in curNode for j in (i.left, i.right) if j]</li><li>the most right element is nextNode[-1].val</li><li>curNode = nextNode</li></ul></li></ul><p>Please consider the corner case: tree is empty.</p><p>Please make sure the node is valid when extracting the val.</p><p><strong>Iterative Python Code: BFS</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self,root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        curNode=[root]</span><br><span class="line">        res.append(root.val)</span><br><span class="line">        <span class="keyword">while</span> curNode:</span><br><span class="line">            nextNode =[j <span class="keyword">for</span> i <span class="keyword">in</span> curNode <span class="keyword">for</span> j <span class="keyword">in</span> (i.left,i.right) <span class="keyword">if</span> j]</span><br><span class="line">            <span class="keyword">if</span> nextNode:</span><br><span class="line">                res.append(nextNode[-<span class="number">1</span>].val)</span><br><span class="line">            curNode = nextNode</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><ul><li>The time complexity is <strong>O(n)</strong>: single loop traversal </li><li>The space complexity is <strong>O(log(n))</strong>: CurNode and NextNode for level elements.</li></ul><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>Depth-First-Search (DFS): Easy to implement by recursive way but difficult to use iterative way</p><p><strong>Recursive DFS python code</strong>:</p><ul><li>Use a list of list  to save all tree elements and the index of the list is the level+1 of the tree</li><li>if length of the list &lt; level +1, we need to add another list for new level</li><li>To write the dfs function using the recursive way, 1) terminate confition first, 2) when the valid node comes, perform operation, 3) then, consider children nodes.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        self.dfs(root,res,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> [i[-<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> res]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self,root,res, level</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; level+<span class="number">1</span>:</span><br><span class="line">            res.append([])</span><br><span class="line">        res[level].append(root.val)</span><br><span class="line">        self.dfs(root.left,res,level+<span class="number">1</span>)</span><br><span class="line">        self.dfs(root.right,res,level+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong>Iterative BFS python code</strong>:</p><ul><li>Use stack</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        stack = [(root,<span class="number">0</span>)]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, level = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(res)&lt;level+<span class="number">1</span>:</span><br><span class="line">                    res.append([])</span><br><span class="line">                res[level].append(node.val)</span><br><span class="line">                stack.append((node.right,level+<span class="number">1</span>))</span><br><span class="line">                stack.append((node.left,level+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> [i[-<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> res]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> dfs </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm: Binary Search</title>
      <link href="2020/11/26/Algorithm-Binary-Search/"/>
      <url>2020/11/26/Algorithm-Binary-Search/</url>
      
        <content type="html"><![CDATA[<p><img src="../../../medias/image/binary_search.png" alt="image"></p><h1 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h1><p>Binary Search (BS) 是一个非常高频的Leetcode 算法题。 BS 经常被用来search ordered elements。当你看到题目涉及到sorted array， binary search tree，算法复杂度 $O(log n)$  或者sort可以让算法变得简单的时候，请优先考虑BS。有些题目没有明确的提示要使用BS， 但是使用BS会大大的提高efficiency。</p><p>写好一个BS算法 看着简单， 其实需要非常高的理解能力。 下面这些坑都是需要踩过了才知道：</p><ul><li>是不是要使用BS： 这一步很关键</li><li>怎么选取 lower 和 upper</li><li>怎么选取 区间：左闭右开 还是闭区间</li><li>怎么决定 next search 区间：move的condition， lower怎么变，upper怎么变</li><li>怎么选取最终结果和terminate condition</li></ul><h1 id="Motivated-Examples"><a href="#Motivated-Examples" class="headerlink" title="Motivated Examples"></a>Motivated Examples</h1><ul><li>BS with variants:<br>Monotone array: Rotated sorted array, Sorted array with duplicates.<br>Target: find the element, find the min/max, find the certain pattern.<ul><li><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">LC 33: Search in Rotated Sorted Array</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You are given an integer array nums sorted in ascending order, and an integer target.</span><br><span class="line">Suppose that nums is rotated at some pivot unknown to you beforehand (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).</span><br><span class="line">If target is found in the array return its index, otherwise, return -1.</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">LC 153. Find Minimum in Rotated Sorted Array</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums &#x3D; [0,1,2,4,5,6,7] might become:</span><br><span class="line">[4,5,6,7,0,1,2] if it was rotated 4 times.</span><br><span class="line">[0,1,2,4,5,6,7] if it was rotated 7 times.</span><br><span class="line">Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].</span><br><span class="line">Given the sorted rotated array nums, return the minimum element of this array.</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">LC 34. Find First and Last Position of Element in Sorted Array</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.</span><br><span class="line">If target is not found in the array, return [-1, -1].</span><br><span class="line">Follow up: Could you write an algorithm with O(log n) runtime complexity?</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode.com/problems/find-peak-element/">LC 162. Find Peak Element</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A peak element is an element that is greater than its neighbors.</span><br><span class="line">Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.</span><br><span class="line">The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</span><br><span class="line">You may imagine that nums[-1] &#x3D; nums[n] &#x3D; -∞.</span><br><span class="line">Follow up: Your solution should be in logarithmic complexity.</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode.com/problems/missing-element-in-sorted-array/">LC 1060. Missing Element in Sorted Array</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given a sorted array A of unique numbers, find the K-th missing number starting from the leftmost number of the array</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="Case-1-BS-for-certain-patterns"><a href="#Case-1-BS-for-certain-patterns" class="headerlink" title="Case 1: BS for certain patterns"></a>Case 1: BS for certain patterns</h1><p>Note that, 当我们用BS search 一个element， 结果可能是找到了也有可能是找不到。但是，但我们用BS search Min/Max的时候， 结果一定存在。有的时候， 我们也会search 一个pattern。比如：mountain peak，第一个大于给定的数的index， 等等。<br>这些不同的target会决定我们使用怎么样的terminate condition和怎么update lower和upper的value。下面我们看一个example。</p><ul><li><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">153. Find Minimum in Rotated Sorted Array</a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span> <span class="comment"># 使用最大最小index</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r: <span class="comment"># terminate的时候 l==r</span></span><br><span class="line">            mid = (l+r)//<span class="number">2</span> <span class="comment"># l+(r-l)//2 </span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&gt;nums[r]: <span class="comment"># 最小值在右边</span></span><br><span class="line">                l = mid+<span class="number">1</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">return</span> nums[l]</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode.com/problems/find-peak-element/">162. Find Peak Element</a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r-<span class="number">1</span>:</span><br><span class="line">            mid = (l+r)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&gt;nums[mid+<span class="number">1</span>] <span class="keyword">and</span> nums[mid]&gt;nums[mid-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid]&lt;=nums[mid+<span class="number">1</span>]:</span><br><span class="line">                l = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l <span class="keyword">if</span> nums[l] &gt;= nums[r] <span class="keyword">else</span> r</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode.com/problems/single-element-in-a-sorted-array/">540. Single Element in a Sorted Array</a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNonDuplicate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">    lo, hi = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">    mid = <span class="number">2</span> * ((lo + hi) // <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">if</span> nums[mid] == nums[mid+<span class="number">1</span>]:</span><br><span class="line">    lo = mid+<span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    hi = mid</span><br><span class="line">    <span class="keyword">return</span> nums[lo]</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode.com/problems/missing-element-in-sorted-array/">1060. Missing Element in Sorted Array</a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingElement</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        l, r, missing = <span class="number">0</span>, n-<span class="number">1</span>, nums[n-<span class="number">1</span>]-nums[<span class="number">0</span>]-n+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; missing:</span><br><span class="line">            <span class="keyword">return</span> k + nums[<span class="number">0</span>] + n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r-<span class="number">1</span>:</span><br><span class="line">            mid = (l+r)//<span class="number">2</span></span><br><span class="line">            mid_missing = nums[mid] - nums[l] - (mid-l)</span><br><span class="line">            <span class="keyword">if</span> mid_missing &lt; k:</span><br><span class="line">                l = mid</span><br><span class="line">                k = k - mid_missinh</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">return</span> nums[l] + k</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">LC 33. Search in Rotated Sorted Array</a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        start, end = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt;= nums[start]:</span><br><span class="line">                <span class="keyword">if</span> target &gt;= nums[start] <span class="keyword">and</span> target &lt; nums[mid]:</span><br><span class="line">                    end = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    start = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> target &lt;= nums[end] <span class="keyword">and</span> target &gt; nums[mid]:</span><br><span class="line">                    start = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>Here are some key points:</p><ul><li>terminate conditions: l &lt; r implies l == r, which is [l,l]. l&lt;=r implies l=r+1, which is [r+1,r]. l &lt; r-1 implies l = r-1, which is [r-1,r]</li><li>if we search for a given target, seperate into 3 cases: return mid, l = mid +1, r = mid -1. Otherwise, l = mid + 1 if we want to move left index.</li><li>For the final output, we need to think it carefully for the terminate conditions.</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/11/24/hello-world/"/>
      <url>2020/11/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
