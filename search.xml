<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Reading Note for  Wide and Deep Learning for Recommender Systems</title>
      <link href="2020/12/25/Wide-and-Deep-Learning-for-Recommender-Systems/"/>
      <url>2020/12/25/Wide-and-Deep-Learning-for-Recommender-Systems/</url>
      
        <content type="html"><![CDATA[<p><strong>Paper link</strong>: <a href="https://arxiv.org/pdf/1606.07792.pdf">Wide &amp; Deep Learning for Recommender Systems</a></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li>The input features are sparse</li><li>Memorization of feature interactions through a wide set of <strong>cross-product</strong> feature transformations are effective and interpretable. However, generalization requires more feature engineering effort.</li><li>Deep neural networks can generalize better to unseen feature combinations through <strong>low-dimensional dense embeddings</strong> learned from the sparse features.</li><li>Therefore, this paper combines two: jointly train wide linear models and deep neural networks.</li></ul><h2 id="Model-Architecture"><a href="#Model-Architecture" class="headerlink" title="Model Architecture"></a>Model Architecture</h2><p><img src="https://1.bp.blogspot.com/-Dw1mB9am1l8/V3MgtOzp3uI/AAAAAAAABGs/mP-3nZQCjWwdk6qCa5WraSpK8A7rSPj3ACLcB/s1600/image04.png" alt="Image"></p><h3 id="Wide-Component"><a href="#Wide-Component" class="headerlink" title="Wide Component"></a>Wide Component</h3><ul><li>Assume y is the prediction and <strong>x</strong> is a vector of d features. The wide component is a generalized linear model of the form <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y &#x3D; w^T x + b</span><br></pre></td></tr></table></figure></li><li>One of the most important transformations is the <strong>cross-product</strong> transformation. For binary features, a cross-product transformation “AND( gender=male, language=en)” is 1 only if gender is male and language is en.</li></ul><p><img src="https://miro.medium.com/max/700/1*XHvOuICw2E9inCJJxIyKUg.png" alt="image"></p><h3 id="Deep-Componennt"><a href="#Deep-Componennt" class="headerlink" title="Deep Componennt"></a>Deep Componennt</h3><ul><li>Each of these sparse high-dimensional categorical features are first converted into a low-dimensional and dense real-valued vector</li><li>Those low-dimensional vectors are then fed into a hidden layers and a neural network</li></ul><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3>]]></content>
      
      
      
        <tags>
            
            <tag> paper </tag>
            
            <tag> recommender system </tag>
            
            <tag> deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 105: Construct Binary Tree from Preorder and InorderTraversal</title>
      <link href="2020/12/25/Leetcode-105-Construct-Binary-Tree-from-Preorder-and-InorderTraversal/"/>
      <url>2020/12/25/Leetcode-105-Construct-Binary-Tree-from-Preorder-and-InorderTraversal/</url>
      
        <content type="html"><![CDATA[<p>Medium</p><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p><p>Note:<br>You may assume that duplicates do not exist in the tree.</p><p>For example, given</p><p>preorder = [3,9,20,15,7]<br>inorder = [9,3,15,20,7]<br>Return the following binary tree:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9   20</span><br><span class="line">   &#x2F; \</span><br><span class="line">  15  7</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Traversal </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 124: Binary Tree Maximum Path Sum</title>
      <link href="2020/12/25/Leetcode-124-Binary-Tree-Maximum-Path-Sum/"/>
      <url>2020/12/25/Leetcode-124-Binary-Tree-Maximum-Path-Sum/</url>
      
        <content type="html"><![CDATA[<p>Hard</p><p>Given a non-empty binary tree, find the maximum path sum.</p><p>For this problem, a path is defined as any node sequence from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.</p><p><strong>Example 1</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   3</span><br></pre></td></tr></table></figure><br><strong>Input</strong>: root = [1,2,3]<br><strong>Output</strong>: 6</p><p><strong>Constraints</strong>:</p><ul><li>The number of nodes in the tree is in the range [0, 3 * 10^4]</li><li>-1000 &lt;= Node.val &lt;= 1000</li></ul><p><strong>Solution</strong>:</p><ul><li>Get the inorder tree traversal: Recursive or Iterative way </li><li><p>Find the maximum summation of sub-array</p><ul><li>DP: get the maximum summation of the subarray ending with the curent element </li><li>dp[i+1] = max(dp[i],0) + nums[i+1]</li></ul></li><li><p>For this problem, we can use the similar idea. Traversal the tree and max value is the max(lef, right, left+node.val+right)</p></li><li>the DP idea: the maximum summation of path values starting or ending with the node: max(node.val + max(left,right),0)</li></ul><p><strong>Recursive Inorder code</strong>:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">maxend</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left = maxend(node.left)</span><br><span class="line">            right = maxend(node.right)</span><br><span class="line">            self.<span class="built_in">max</span> = <span class="built_in">max</span>(self.<span class="built_in">max</span>, left + node.val + right)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(node.val + <span class="built_in">max</span>(left, right), <span class="number">0</span>)</span><br><span class="line">        self.<span class="built_in">max</span> = -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        maxend(root)</span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">max</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Binary Tree </tag>
            
            <tag> Tree Traversal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 297: Serialize and Deserialize Binary Tree</title>
      <link href="2020/12/24/Leetcode-297-Serialize-and-Deserialize-Binary-Tree/"/>
      <url>2020/12/24/Leetcode-297-Serialize-and-Deserialize-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<p>Hard</p><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p><p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p><p>Clarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p><p><strong>Example 1</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   1</span><br><span class="line"> &#x2F;  \</span><br><span class="line">2    3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br></pre></td></tr></table></figure><br>Input: root = [1,2,3,null,null,4,5]<br>Output: [1,2,3,null,null,4,5]</p><p><strong>Idea</strong>:</p><ul><li>We need to traversal the tree. Hence, consider BFS or DFS</li><li>We need to recustruct the tree from the serialized string. Hence, we need two key information: separating char and tree structure.</li><li>Given a string, we can split them by any special char, saying ‘#’.</li><li>For the tree structure, we need to know: left and right nodes. Hence, we need the order information.</li></ul><p><strong>BFS python code</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Encodes a tree to a single string.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        res = []</span><br><span class="line">        curNode = [root]</span><br><span class="line">        <span class="keyword">while</span> curNode:</span><br><span class="line">            nextNode = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> curNode:</span><br><span class="line">                res.append(<span class="built_in">str</span>(node.val) <span class="keyword">if</span> node <span class="keyword">else</span> <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> node:</span><br><span class="line">                    nextNode.append(node.left)</span><br><span class="line">                    nextNode.append(node.right)</span><br><span class="line">            curNode = nextNode</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;.&#x27;</span>.join(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        res = data.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        ind = <span class="number">1</span></span><br><span class="line">        head = TreeNode(<span class="built_in">int</span>(res[<span class="number">0</span>]))</span><br><span class="line">        curNode = [head]</span><br><span class="line">        <span class="keyword">while</span> curNode:</span><br><span class="line">            nextNode = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> curNode:</span><br><span class="line">                <span class="keyword">if</span> res[ind]!=<span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                    nd=TreeNode(<span class="built_in">int</span>(res[ind]))</span><br><span class="line">                    nextNode.append(nd)</span><br><span class="line">                    node.left = nd</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node.left = <span class="literal">None</span></span><br><span class="line">                ind +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> res[ind] == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                    node.right = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nd = TreeNode(<span class="built_in">int</span>(res[ind]))</span><br><span class="line">                    nextNode.append(nd)</span><br><span class="line">                    node.right = nd</span><br><span class="line">                ind +=<span class="number">1</span></span><br><span class="line">            curNode = nextNode</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p><strong> recursive DFS python code </strong>:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Encodes a tree to a single string.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">rserialize</span>(<span class="params">root,string</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                string += <span class="string">&#x27;#.&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                string += <span class="built_in">str</span>(root.val) + <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                string = rserialize(root.left, string)</span><br><span class="line">                string = rserialize(root.right, string)</span><br><span class="line">            <span class="keyword">return</span> string</span><br><span class="line">        <span class="keyword">return</span> rserialize(root, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">rdeserialize</span>(<span class="params">l</span>):</span></span><br><span class="line">            <span class="keyword">if</span> l[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                l.popleft()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            root = TreeNode(<span class="built_in">int</span>(l[<span class="number">0</span>]))</span><br><span class="line">            l.popleft()</span><br><span class="line">            root.left = rdeserialize(l)</span><br><span class="line">            root.right = rdeserialize(l)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        dlist = collections.deque(data.split(<span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">        root = rdeserialize(dlist)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reading Note: Improving Web Search Ranking by Incorporating User Behavior Information</title>
      <link href="2020/12/23/Reading-Note-Improving-Web-Search-Ranking-by-Incorporating-User-Behavior-Information/"/>
      <url>2020/12/23/Reading-Note-Improving-Web-Search-Ranking-by-Incorporating-User-Behavior-Information/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p> This paper explores whether implicit feedback can be helpful in realistic environments, where user feedback can be noisy and a web search engine already uses hundreds of features and is heavily tuned.</p><p> <strong>Contributions</strong>:</p><ul><li>Analysis of alternatives for incoporating user behavior into web search ranking</li><li>An application of a robust implicit feedback model</li><li>A large scale evaluation</li></ul><h2 id="Incorporating-Implicit-Feedback"><a href="#Incorporating-Implicit-Feedback" class="headerlink" title="Incorporating Implicit Feedback"></a>Incorporating Implicit Feedback</h2><ul><li><p><strong>Treating implicit feedback as independent evidence for ranking results</strong>:</p><ul><li>Re-rank the results obtained by a web search engine </li><li>Each result is assigned a score according to expected relevance/user satisfaction</li><li>For a given query <strong>q</strong>, the implicit score $IS_d$ is computed for each result $d$ from available user interaction features</li><li>The implicit score results in the implicit rank $I_d$ for each result</li><li>The original score rank is $O_d$</li><li>We compute the merged score: $S_M(d)= w_I \frac{1}{I_d+1}+\frac{1}{O_d+1}$ if implicit feedback exists for $d$.</li><li>Otherwise, $S_M(d) = \frac{1}{O_d}$</li></ul></li><li><p><strong>Ranking with implicit feedback features</strong>:</p><ul><li>Incorporate implicit feedback features directly as features for the ranking algorithm.</li><li>This model requires a ranking algorithm to be robust to missing values: more than 50% of queries are unique( without previous implicit feedback)</li><li>Use a 2-layer implementation of RankNet in order to model non-linear relationships between features.</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Web Search </tag>
            
            <tag> Implicit relevance feedback </tag>
            
            <tag> Web search ranking </tag>
            
            <tag> Paper reading notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 199: Binary Tree Right Side View</title>
      <link href="2020/12/23/Leetcode-199-Binary-Tree-Right-Side-View/"/>
      <url>2020/12/23/Leetcode-199-Binary-Tree-Right-Side-View/</url>
      
        <content type="html"><![CDATA[<p>Medium</p><p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p><p><strong>Example</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,null,5,null,4]</span><br><span class="line">Output: [1, 3, 4]</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure></p><p>When you need to search some values from the tree, please consider the tree traversal methods: BFS and DFS. For this specific problem, we need to find the most right elements at each level. Therefore, we need to find the level information and save all elements from the same level. It seems that BFS is easy to use. In most cases, dfs also performs the similar function of BFS in a different traversal trace. </p><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>Breath-First-Search (BFS): </p><ul><li>Initial current node list: curNode = [root]</li><li>while curNode is not empty:<ul><li>nextNode = [j for i in curNode for j in (i.left, i.right) if j]</li><li>the most right element is nextNode[-1].val</li><li>curNode = nextNode</li></ul></li></ul><p>Please consider the corner case: tree is empty.</p><p>Please make sure the node is valid when extracting the val.</p><p><strong>Iterative Python Code: BFS</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self,root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        curNode=[root]</span><br><span class="line">        res.append(root.val)</span><br><span class="line">        <span class="keyword">while</span> curNode:</span><br><span class="line">            nextNode =[j <span class="keyword">for</span> i <span class="keyword">in</span> curNode <span class="keyword">for</span> j <span class="keyword">in</span> (i.left,i.right) <span class="keyword">if</span> j]</span><br><span class="line">            <span class="keyword">if</span> nextNode:</span><br><span class="line">                res.append(nextNode[-<span class="number">1</span>].val)</span><br><span class="line">            curNode = nextNode</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><ul><li>The time complexity is <strong>O(n)</strong>: single loop traversal </li><li>The space complexity is <strong>O(log(n))</strong>: CurNode and NextNode for level elements.</li></ul><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>Depth-First-Search (DFS): Easy to implement by recursive way but difficult to use iterative way</p><p><strong>Recursive DFS python code</strong>:</p><ul><li>Use a list of list  to save all tree elements and the index of the list is the level+1 of the tree</li><li>if length of the list &lt; level +1, we need to add another list for new level</li><li>To write the dfs function using the recursive way, 1) terminate confition first, 2) when the valid node comes, perform operation, 3) then, consider children nodes.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        self.dfs(root,res,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> [i[-<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> res]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self,root,res, level</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; level+<span class="number">1</span>:</span><br><span class="line">            res.append([])</span><br><span class="line">        res[level].append(root.val)</span><br><span class="line">        self.dfs(root.left,res,level+<span class="number">1</span>)</span><br><span class="line">        self.dfs(root.right,res,level+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong>Iterative BFS python code</strong>:</p><ul><li>Use stack</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        stack = [(root,<span class="number">0</span>)]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, level = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(res)&lt;level+<span class="number">1</span>:</span><br><span class="line">                    res.append([])</span><br><span class="line">                res[level].append(node.val)</span><br><span class="line">                stack.append((node.right,level+<span class="number">1</span>))</span><br><span class="line">                stack.append((node.left,level+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> [i[-<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> res]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> dfs </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm: Binary Search</title>
      <link href="2020/11/26/Algorithm-Binary-Search/"/>
      <url>2020/11/26/Algorithm-Binary-Search/</url>
      
        <content type="html"><![CDATA[<p><img src="../../../medias/image/binary_search.png" alt="image"></p><h1 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h1><p>Binary Search (BS) 是一个非常高频的Leetcode 算法题。 BS 经常被用来search ordered elements。当你看到题目涉及到sorted array， binary search tree，算法复杂度 $O(log n)$  或者sort可以让算法变得简单的时候，请优先考虑BS。有些题目没有明确的提示要使用BS， 但是使用BS会大大的提高efficiency。</p><p>写好一个BS算法 看着简单， 其实需要非常高的理解能力。 下面这些坑都是需要踩过了才知道：</p><ul><li>是不是要使用BS： 这一步很关键</li><li>怎么选取 lower 和 upper</li><li>怎么选取 区间：左闭右开 还是闭区间</li><li>怎么决定 next search 区间：move的condition， lower怎么变，upper怎么变</li><li>怎么选取最终结果和terminate condition</li></ul><h1 id="Motivated-Examples"><a href="#Motivated-Examples" class="headerlink" title="Motivated Examples"></a>Motivated Examples</h1><ul><li>BS with variants:<br>Monotone array: Rotated sorted array, Sorted array with duplicates.<br>Target: find the element, find the min/max, find the certain pattern.<ul><li><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">LC 33: Search in Rotated Sorted Array</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You are given an integer array nums sorted in ascending order, and an integer target.</span><br><span class="line">Suppose that nums is rotated at some pivot unknown to you beforehand (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).</span><br><span class="line">If target is found in the array return its index, otherwise, return -1.</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">LC 153. Find Minimum in Rotated Sorted Array</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums &#x3D; [0,1,2,4,5,6,7] might become:</span><br><span class="line">[4,5,6,7,0,1,2] if it was rotated 4 times.</span><br><span class="line">[0,1,2,4,5,6,7] if it was rotated 7 times.</span><br><span class="line">Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].</span><br><span class="line">Given the sorted rotated array nums, return the minimum element of this array.</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">LC 34. Find First and Last Position of Element in Sorted Array</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.</span><br><span class="line">If target is not found in the array, return [-1, -1].</span><br><span class="line">Follow up: Could you write an algorithm with O(log n) runtime complexity?</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode.com/problems/find-peak-element/">LC 162. Find Peak Element</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A peak element is an element that is greater than its neighbors.</span><br><span class="line">Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.</span><br><span class="line">The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</span><br><span class="line">You may imagine that nums[-1] &#x3D; nums[n] &#x3D; -∞.</span><br><span class="line">Follow up: Your solution should be in logarithmic complexity.</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode.com/problems/missing-element-in-sorted-array/">LC 1060. Missing Element in Sorted Array</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given a sorted array A of unique numbers, find the K-th missing number starting from the leftmost number of the array</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="Case-1-BS-for-certain-patterns"><a href="#Case-1-BS-for-certain-patterns" class="headerlink" title="Case 1: BS for certain patterns"></a>Case 1: BS for certain patterns</h1><p>Note that, 当我们用BS search 一个element， 结果可能是找到了也有可能是找不到。但是，但我们用BS search Min/Max的时候， 结果一定存在。有的时候， 我们也会search 一个pattern。比如：mountain peak，第一个大于给定的数的index， 等等。<br>这些不同的target会决定我们使用怎么样的terminate condition和怎么update lower和upper的value。下面我们看一个example。</p><ul><li><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">153. Find Minimum in Rotated Sorted Array</a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span> <span class="comment"># 使用最大最小index</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r: <span class="comment"># terminate的时候 l==r</span></span><br><span class="line">            mid = (l+r)//<span class="number">2</span> <span class="comment"># l+(r-l)//2 </span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&gt;nums[r]: <span class="comment"># 最小值在右边</span></span><br><span class="line">                l = mid+<span class="number">1</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">return</span> nums[l]</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode.com/problems/find-peak-element/">162. Find Peak Element</a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r-<span class="number">1</span>:</span><br><span class="line">            mid = (l+r)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&gt;nums[mid+<span class="number">1</span>] <span class="keyword">and</span> nums[mid]&gt;nums[mid-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid]&lt;=nums[mid+<span class="number">1</span>]:</span><br><span class="line">                l = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l <span class="keyword">if</span> nums[l] &gt;= nums[r] <span class="keyword">else</span> r</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode.com/problems/single-element-in-a-sorted-array/">540. Single Element in a Sorted Array</a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNonDuplicate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">    lo, hi = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">    mid = <span class="number">2</span> * ((lo + hi) // <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">if</span> nums[mid] == nums[mid+<span class="number">1</span>]:</span><br><span class="line">    lo = mid+<span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    hi = mid</span><br><span class="line">    <span class="keyword">return</span> nums[lo]</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode.com/problems/missing-element-in-sorted-array/">1060. Missing Element in Sorted Array</a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingElement</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        l, r, missing = <span class="number">0</span>, n-<span class="number">1</span>, nums[n-<span class="number">1</span>]-nums[<span class="number">0</span>]-n+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; missing:</span><br><span class="line">            <span class="keyword">return</span> k + nums[<span class="number">0</span>] + n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r-<span class="number">1</span>:</span><br><span class="line">            mid = (l+r)//<span class="number">2</span></span><br><span class="line">            mid_missing = nums[mid] - nums[l] - (mid-l)</span><br><span class="line">            <span class="keyword">if</span> mid_missing &lt; k:</span><br><span class="line">                l = mid</span><br><span class="line">                k = k - mid_missinh</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">return</span> nums[l] + k</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">LC 33. Search in Rotated Sorted Array</a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        start, end = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt;= nums[start]:</span><br><span class="line">                <span class="keyword">if</span> target &gt;= nums[start] <span class="keyword">and</span> target &lt; nums[mid]:</span><br><span class="line">                    end = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    start = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> target &lt;= nums[end] <span class="keyword">and</span> target &gt; nums[mid]:</span><br><span class="line">                    start = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>Here are some key points:</p><ul><li>terminate conditions: l &lt; r implies l == r, which is [l,l]. l&lt;=r implies l=r+1, which is [r+1,r]. l &lt; r-1 implies l = r-1, which is [r-1,r]</li><li>if we search for a given target, seperate into 3 cases: return mid, l = mid +1, r = mid -1. Otherwise, l = mid + 1 if we want to move left index.</li><li>For the final output, we need to think it carefully for the terminate conditions.</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/11/24/hello-world/"/>
      <url>2020/11/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
