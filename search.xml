<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Leetcode 199: Binary Tree Right Side View</title>
      <link href="2020/12/23/Leetcode-199-Binary-Tree-Right-Side-View/"/>
      <url>2020/12/23/Leetcode-199-Binary-Tree-Right-Side-View/</url>
      
        <content type="html"><![CDATA[<p>Medium</p><p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p><p><strong>Example</strong>:</p><pre><code>Input: [1,2,3,null,5,null,4]Output: [1, 3, 4]Explanation:   1            &lt;--- /   \2     3         &lt;--- \     \  5     4       &lt;---</code></pre><p>When you need to search some values from the tree, please consider the tree traversal methods: BFS and DFS. For this specific problem, we need to find the most right elements at each level. Therefore, we need to find the level information and save all elements from the same level. It seems that BFS is easy to use. In most cases, dfs also performs the similar function of BFS in a different traversal trace. </p><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>Breath-First-Search (BFS): </p><ul><li>Initial current node list: curNode = [root]</li><li>while curNode is not empty:<ul><li>nextNode = [j for i in curNode for j in (i.left, i.right) if j]</li><li>the most right element is nextNode[-1].val</li><li>curNode = nextNode</li></ul></li></ul><p>Please consider the corner case: tree is empty.</p><p>Please make sure the node is valid when extracting the val.</p><p><strong>Iterative Python Code: BFS</strong></p><pre class=" language-lang-python"><code class="language-lang-python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def rightSideView(self,root: TreeNode) -> List[int]:        res = []        if not root:            return res        curNode=[root]        res.append(root.val)        while curNode:            nextNode =[j for i in curNode for j in (i.left,i.right) if j]            if nextNode:                res.append(nextNode[-1].val)            curNode = nextNode        return res</code></pre><ul><li>The time complexity is <strong>O(n)</strong>: single loop traversal </li><li>The space complexity is <strong>O(log(n))</strong>: CurNode and NextNode for level elements.</li></ul><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>Depth-First-Search (DFS): Easy to implement by recursive way but difficult to use iterative way</p><p><strong>Recursive DFS python code</strong>:</p><ul><li>Use a list of list  to save all tree elements and the index of the list is the level+1 of the tree</li><li>if length of the list &lt; level +1, we need to add another list for new level</li><li>To write the dfs function using the recursive way, 1) terminate confition first, 2) when the valid node comes, perform operation, 3) then, consider children nodes.</li></ul><pre class=" language-lang-python"><code class="language-lang-python">class Solution:    def rightSideView(self, root: TreeNode) -> List[int]:        res = []        if not root:            return res        self.dfs(root,res,0)        return [i[-1] for i in res]    def dfs(self,root,res, level):        if not root:            return        if len(res) < level+1:            res.append([])        res[level].append(root.val)        self.dfs(root.left,res,level+1)        self.dfs(root.right,res,level+1)</code></pre><p><strong>Iterative BFS python code</strong>:</p><ul><li>Use stack</li></ul><pre class=" language-lang-python"><code class="language-lang-python">class Solution:    def rightSideView(self, root: TreeNode) -> List[int]:        res = []        if not root:            return res        stack = [(root,0)]        while stack:            node, level = stack.pop()            if node:                if len(res)<level+1:                    res.append([])                res[level].append(node.val)                stack.append((node.right,level+1))                stack.append((node.left,level+1))        return [i[-1] for i in res]</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> dfs </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm: Binary Search</title>
      <link href="2020/11/26/Algorithm-Binary-Search/"/>
      <url>2020/11/26/Algorithm-Binary-Search/</url>
      
        <content type="html"><![CDATA[<p><img src="../../../medias/image/binary_search.png" alt="image"></p><h1 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h1><p>Binary Search (BS) 是一个非常高频的Leetcode 算法题。 BS 经常被用来search ordered elements。当你看到题目涉及到sorted array， binary search tree，算法复杂度 $O(log n)$  或者sort可以让算法变得简单的时候，请优先考虑BS。有些题目没有明确的提示要使用BS， 但是使用BS会大大的提高efficiency。</p><p>写好一个BS算法 看着简单， 其实需要非常高的理解能力。 下面这些坑都是需要踩过了才知道：</p><ul><li>是不是要使用BS： 这一步很关键</li><li>怎么选取 lower 和 upper</li><li>怎么选取 区间：左闭右开 还是闭区间</li><li>怎么决定 next search 区间：move的condition， lower怎么变，upper怎么变</li><li>怎么选取最终结果和terminate condition</li></ul><h1 id="Motivated-Examples"><a href="#Motivated-Examples" class="headerlink" title="Motivated Examples"></a>Motivated Examples</h1><ul><li>BS with variants:<br>Monotone array: Rotated sorted array, Sorted array with duplicates.<br>Target: find the element, find the min/max, find the certain pattern.<ul><li><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">LC 33: Search in Rotated Sorted Array</a><pre><code>You are given an integer array nums sorted in ascending order, and an integer target.Suppose that nums is rotated at some pivot unknown to you beforehand (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).If target is found in the array return its index, otherwise, return -1.</code></pre></li><li><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">LC 153. Find Minimum in Rotated Sorted Array</a><pre><code>Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:[4,5,6,7,0,1,2] if it was rotated 4 times.[0,1,2,4,5,6,7] if it was rotated 7 times.Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].Given the sorted rotated array nums, return the minimum element of this array.</code></pre></li><li><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">LC 34. Find First and Last Position of Element in Sorted Array</a><pre><code>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.If target is not found in the array, return [-1, -1].Follow up: Could you write an algorithm with O(log n) runtime complexity?</code></pre></li><li><a href="https://leetcode.com/problems/find-peak-element/">LC 162. Find Peak Element</a><pre><code>A peak element is an element that is greater than its neighbors.Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.You may imagine that nums[-1] = nums[n] = -∞.Follow up: Your solution should be in logarithmic complexity.</code></pre></li><li><a href="https://leetcode.com/problems/missing-element-in-sorted-array/">LC 1060. Missing Element in Sorted Array</a><pre><code>Given a sorted array A of unique numbers, find the K-th missing number starting from the leftmost number of the array</code></pre></li></ul></li></ul><h1 id="Case-1-BS-for-certain-patterns"><a href="#Case-1-BS-for-certain-patterns" class="headerlink" title="Case 1: BS for certain patterns"></a>Case 1: BS for certain patterns</h1><p>Note that, 当我们用BS search 一个element， 结果可能是找到了也有可能是找不到。但是，但我们用BS search Min/Max的时候， 结果一定存在。有的时候， 我们也会search 一个pattern。比如：mountain peak，第一个大于给定的数的index， 等等。<br>这些不同的target会决定我们使用怎么样的terminate condition和怎么update lower和upper的value。下面我们看一个example。</p><ul><li><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">153. Find Minimum in Rotated Sorted Array</a><pre class=" language-lang-python"><code class="language-lang-python">class Solution:  def findMin(self, nums: List[int]) -> int:      l, r = 0, len(nums)-1 # 使用最大最小index      while l < r: # terminate的时候 l==r          mid = (l+r)//2 # l+(r-l)//2           if nums[mid]>nums[r]: # 最小值在右边              l = mid+1           else:              r = mid      return nums[l]</code></pre></li><li><a href="https://leetcode.com/problems/find-peak-element/">162. Find Peak Element</a><pre class=" language-lang-python"><code class="language-lang-python">class Solution:  def findPeakElement(self, nums: List[int]) -> int:      l, r = 0, len(nums)-1      while l < r-1:          mid = (l+r)//2          if nums[mid]>nums[mid+1] and nums[mid]>nums[mid-1]:              return mid          elif nums[mid]<=nums[mid+1]:              l = mid+1          else:              r = mid-1      return l if nums[l] >= nums[r] else r</code></pre></li><li><a href="https://leetcode.com/problems/single-element-in-a-sorted-array/">540. Single Element in a Sorted Array</a><pre class=" language-lang-python"><code class="language-lang-python">class Solution:  def singleNonDuplicate(self, nums: List[int]) -> int:      lo, hi = 0, len(nums) - 1      while lo < hi:          mid = 2 * ((lo + hi) // 4)          if nums[mid] == nums[mid+1]:              lo = mid+2          else:              hi = mid      return nums[lo]</code></pre></li><li><a href="https://leetcode.com/problems/missing-element-in-sorted-array/">1060. Missing Element in Sorted Array</a><pre class=" language-lang-python"><code class="language-lang-python">class Solution:  def missingElement(self, nums: List[int], k: int) -> int:      n = len(nums)      l, r, missing = 0, n-1, nums[n-1]-nums[0]-n+1      if k > missing:          return k + nums[0] + n - 1      while l < r-1:          mid = (l+r)//2          mid_missing = nums[mid] - nums[l] - (mid-l)          if mid_missing < k:              l = mid              k = k - mid_missinh          else:              r = mid      return nums[l] + k</code></pre></li><li><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">LC 33. Search in Rotated Sorted Array</a><pre class=" language-lang-python"><code class="language-lang-python">class Solution:  def search(self, nums: List[int], target: int) -> int:      start, end = 0, len(nums) - 1      while start <= end:          mid = start + (end - start) // 2          if nums[mid] == target:              return mid          elif nums[mid] >= nums[start]:              if target >= nums[start] and target < nums[mid]:                  end = mid - 1              else:                  start = mid + 1          else:              if target <= nums[end] and target > nums[mid]:                  start = mid + 1              else:                  end = mid - 1      return -1</code></pre></li></ul><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>Here are some key points:</p><ul><li>terminate conditions: l &lt; r implies l == r, which is [l,l]. l&lt;=r implies l=r+1, which is [r+1,r]. l &lt; r-1 implies l = r-1, which is [r-1,r]</li><li>if we search for a given target, seperate into 3 cases: return mid, l = mid +1, r = mid -1. Otherwise, l = mid + 1 if we want to move left index.</li><li>For the final output, we need to think it carefully for the terminate conditions.</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/11/24/hello-world/"/>
      <url>2020/11/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
