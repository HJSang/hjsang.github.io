<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>学习笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="新东西这么多 一个一个开始学">
<meta property="og:type" content="website">
<meta property="og:title" content="学习笔记">
<meta property="og:url" content="http://hjsang.github.io/page/3/index.html">
<meta property="og:site_name" content="学习笔记">
<meta property="og:description" content="新东西这么多 一个一个开始学">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Hejian Sang">
<meta property="article:tag" content="课程笔记，总结记录，阅读笔记">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="学习笔记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">学习笔记</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://hjsang.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Wide-and-Deep-Learning-for-Recommender-Systems" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/25/Wide-and-Deep-Learning-for-Recommender-Systems/" class="article-date">
  <time datetime="2020-12-25T20:47:32.000Z" itemprop="datePublished">2020-12-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/25/Wide-and-Deep-Learning-for-Recommender-Systems/">Reading Note for  Wide and Deep Learning for Recommender Systems</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>Paper link</strong>: <a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1606.07792.pdf">Wide &amp; Deep Learning for Recommender Systems</a></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul>
<li>The input features are sparse</li>
<li>Memorization of feature interactions through a wide set of <strong>cross-product</strong> feature transformations are effective and interpretable. However, generalization requires more feature engineering effort.</li>
<li>Deep neural networks can generalize better to unseen feature combinations through <strong>low-dimensional dense embeddings</strong> learned from the sparse features.</li>
<li>Therefore, this paper combines two: jointly train wide linear models and deep neural networks.</li>
</ul>
<h2 id="Model-Architecture"><a href="#Model-Architecture" class="headerlink" title="Model Architecture"></a>Model Architecture</h2><p><img src="https://1.bp.blogspot.com/-Dw1mB9am1l8/V3MgtOzp3uI/AAAAAAAABGs/mP-3nZQCjWwdk6qCa5WraSpK8A7rSPj3ACLcB/s1600/image04.png" alt="Image"></p>
<h3 id="Wide-Component"><a href="#Wide-Component" class="headerlink" title="Wide Component"></a>Wide Component</h3><ul>
<li>Assume y is the prediction and <strong>x</strong> is a vector of d features. The wide component is a generalized linear model of the form <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y &#x3D; w^T x + b</span><br></pre></td></tr></table></figure></li>
<li>One of the most important transformations is the <strong>cross-product</strong> transformation. For binary features, a cross-product transformation “AND( gender=male, language=en)” is 1 only if gender is male and language is en.</li>
</ul>
<p><img src="https://miro.medium.com/max/700/1*XHvOuICw2E9inCJJxIyKUg.png" alt="image"></p>
<h3 id="Deep-Componennt"><a href="#Deep-Componennt" class="headerlink" title="Deep Componennt"></a>Deep Componennt</h3><ul>
<li>Each of these sparse high-dimensional categorical features are first converted into a low-dimensional and dense real-valued vector</li>
<li>Those low-dimensional vectors are then fed into a hidden layers and a neural network</li>
</ul>
<h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p><img src="https://raw.githubusercontent.com/HJSang/hjsang.github.io/main/medias/image/wide_deep_model.png" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hjsang.github.io/2020/12/25/Wide-and-Deep-Learning-for-Recommender-Systems/" data-id="ckj4sm31i000crdu2hqol9we4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/source/tags/deep-learning/" rel="tag">deep learning</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/source/tags/paper/" rel="tag">paper</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/source/tags/recommender-system/" rel="tag">recommender system</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Leetcode-105-Construct-Binary-Tree-from-Preorder-and-InorderTraversal" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/25/Leetcode-105-Construct-Binary-Tree-from-Preorder-and-InorderTraversal/" class="article-date">
  <time datetime="2020-12-25T15:35:39.000Z" itemprop="datePublished">2020-12-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/25/Leetcode-105-Construct-Binary-Tree-from-Preorder-and-InorderTraversal/">Leetcode 105: Construct Binary Tree from Preorder and InorderTraversal</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Medium</p>
<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may assume that duplicates do not exist in the tree.</p>
<p>For example, given</p>
<p>preorder = [3,9,20,15,7]<br>inorder = [9,3,15,20,7]<br>Return the following binary tree:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9   20</span><br><span class="line">   &#x2F; \</span><br><span class="line">  15  7</span><br></pre></td></tr></table></figure>
<p><strong>Solution</strong>:</p>
<ul>
<li>Please noet that: preorder =[root, root.left, root.right] and inorder = [root.left, root, root.right]. </li>
<li>root.left and root.right can be none</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: List[<span class="built_in">int</span>], inorder: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> inorder:</span><br><span class="line">            root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">            ind = inorder.index(preorder[<span class="number">0</span>])</span><br><span class="line">            preorder.pop(<span class="number">0</span>)</span><br><span class="line">            root.left = self.buildTree(preorder,inorder[:ind])</span><br><span class="line">            root.right = self.buildTree(preorder,inorder[ind+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: List[<span class="built_in">int</span>], inorder: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># empty tree</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder: <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># Create ierator for preorder and inorder</span></span><br><span class="line">        preorder_iter, inorder_iter = <span class="built_in">iter</span>(preorder), <span class="built_in">iter</span>(inorder)</span><br><span class="line">        <span class="comment"># Initial root as the first element in preorder and initialize the current inorder val</span></span><br><span class="line">        root, curr_inorder_val = TreeNode(<span class="built_in">next</span>(preorder_iter)), <span class="built_in">next</span>(inorder_iter)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># stack is used to track left trees</span></span><br><span class="line">        <span class="comment"># build_right_tree is a flag to indicate if it is the time to build the right tree</span></span><br><span class="line">        stack, node, build_right_tree = [root], root, <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>].val == curr_inorder_val:</span><br><span class="line">                    node = stack.pop() <span class="comment"># now it is the root node, and onto building its right tree.</span></span><br><span class="line">                    curr_inorder_val = <span class="built_in">next</span>(inorder_iter)</span><br><span class="line">                    build_right_tree = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> build_right_tree:</span><br><span class="line">                        node.right = TreeNode(<span class="built_in">next</span>(preorder_iter))</span><br><span class="line">                        node = node.right</span><br><span class="line">                        build_right_tree = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        node.left = TreeNode(<span class="built_in">next</span>(preorder_iter))</span><br><span class="line">                        node = node.left</span><br><span class="line"></span><br><span class="line">                    stack.append(node)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hjsang.github.io/2020/12/25/Leetcode-105-Construct-Binary-Tree-from-Preorder-and-InorderTraversal/" data-id="ckj4sm3140003rdu2dum3anr6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/source/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/source/tags/Stack/" rel="tag">Stack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/source/tags/Traversal/" rel="tag">Traversal</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/source/tags/Tree/" rel="tag">Tree</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Leetcode-124-Binary-Tree-Maximum-Path-Sum" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/25/Leetcode-124-Binary-Tree-Maximum-Path-Sum/" class="article-date">
  <time datetime="2020-12-25T14:42:28.000Z" itemprop="datePublished">2020-12-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/25/Leetcode-124-Binary-Tree-Maximum-Path-Sum/">Leetcode 124: Binary Tree Maximum Path Sum</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Hard</p>
<p>Given a non-empty binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any node sequence from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.</p>
<p><strong>Example 1</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   3</span><br></pre></td></tr></table></figure><br><strong>Input</strong>: root = [1,2,3]<br><strong>Output</strong>: 6</p>
<p><strong>Constraints</strong>:</p>
<ul>
<li>The number of nodes in the tree is in the range [0, 3 * 10^4]</li>
<li>-1000 &lt;= Node.val &lt;= 1000</li>
</ul>
<p><strong>Solution</strong>:</p>
<ul>
<li>Get the inorder tree traversal: Recursive or Iterative way </li>
<li><p>Find the maximum summation of sub-array</p>
<ul>
<li>DP: get the maximum summation of the subarray ending with the curent element </li>
<li>dp[i+1] = max(dp[i],0) + nums[i+1]</li>
</ul>
</li>
<li><p>For this problem, we can use the similar idea. Traversal the tree and max value is the max(lef, right, left+node.val+right)</p>
</li>
<li>the DP idea: the maximum summation of path values starting or ending with the node: max(node.val + max(left,right),0)</li>
</ul>
<p><strong>Recursive Inorder code</strong>:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">maxend</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left = maxend(node.left)</span><br><span class="line">            right = maxend(node.right)</span><br><span class="line">            self.<span class="built_in">max</span> = <span class="built_in">max</span>(self.<span class="built_in">max</span>, left + node.val + right)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(node.val + <span class="built_in">max</span>(left, right), <span class="number">0</span>)</span><br><span class="line">        self.<span class="built_in">max</span> = -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        maxend(root)</span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">max</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hjsang.github.io/2020/12/25/Leetcode-124-Binary-Tree-Maximum-Path-Sum/" data-id="ckj4sm31a0006rdu2hhw79q46" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/source/tags/Binary-Tree/" rel="tag">Binary Tree</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/source/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/source/tags/Tree/" rel="tag">Tree</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/source/tags/Tree-Traversal/" rel="tag">Tree Traversal</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Leetcode-297-Serialize-and-Deserialize-Binary-Tree" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/24/Leetcode-297-Serialize-and-Deserialize-Binary-Tree/" class="article-date">
  <time datetime="2020-12-24T21:26:28.000Z" itemprop="datePublished">2020-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/24/Leetcode-297-Serialize-and-Deserialize-Binary-Tree/">Leetcode 297: Serialize and Deserialize Binary Tree</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Hard</p>
<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>
<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<p>Clarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p>
<p><strong>Example 1</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   1</span><br><span class="line"> &#x2F;  \</span><br><span class="line">2    3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br></pre></td></tr></table></figure><br>Input: root = [1,2,3,null,null,4,5]<br>Output: [1,2,3,null,null,4,5]</p>
<p><strong>Idea</strong>:</p>
<ul>
<li>We need to traversal the tree. Hence, consider BFS or DFS</li>
<li>We need to recustruct the tree from the serialized string. Hence, we need two key information: separating char and tree structure.</li>
<li>Given a string, we can split them by any special char, saying ‘#’.</li>
<li>For the tree structure, we need to know: left and right nodes. Hence, we need the order information.</li>
</ul>
<p><strong>BFS python code</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Encodes a tree to a single string.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        res = []</span><br><span class="line">        curNode = [root]</span><br><span class="line">        <span class="keyword">while</span> curNode:</span><br><span class="line">            nextNode = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> curNode:</span><br><span class="line">                res.append(<span class="built_in">str</span>(node.val) <span class="keyword">if</span> node <span class="keyword">else</span> <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> node:</span><br><span class="line">                    nextNode.append(node.left)</span><br><span class="line">                    nextNode.append(node.right)</span><br><span class="line">            curNode = nextNode</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;.&#x27;</span>.join(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        res = data.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        ind = <span class="number">1</span></span><br><span class="line">        head = TreeNode(<span class="built_in">int</span>(res[<span class="number">0</span>]))</span><br><span class="line">        curNode = [head]</span><br><span class="line">        <span class="keyword">while</span> curNode:</span><br><span class="line">            nextNode = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> curNode:</span><br><span class="line">                <span class="keyword">if</span> res[ind]!=<span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                    nd=TreeNode(<span class="built_in">int</span>(res[ind]))</span><br><span class="line">                    nextNode.append(nd)</span><br><span class="line">                    node.left = nd</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node.left = <span class="literal">None</span></span><br><span class="line">                ind +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> res[ind] == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                    node.right = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nd = TreeNode(<span class="built_in">int</span>(res[ind]))</span><br><span class="line">                    nextNode.append(nd)</span><br><span class="line">                    node.right = nd</span><br><span class="line">                ind +=<span class="number">1</span></span><br><span class="line">            curNode = nextNode</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<p><strong> recursive DFS python code </strong>:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Encodes a tree to a single string.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">rserialize</span>(<span class="params">root,string</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                string += <span class="string">&#x27;#.&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                string += <span class="built_in">str</span>(root.val) + <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                string = rserialize(root.left, string)</span><br><span class="line">                string = rserialize(root.right, string)</span><br><span class="line">            <span class="keyword">return</span> string</span><br><span class="line">        <span class="keyword">return</span> rserialize(root, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">rdeserialize</span>(<span class="params">l</span>):</span></span><br><span class="line">            <span class="keyword">if</span> l[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                l.popleft()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            root = TreeNode(<span class="built_in">int</span>(l[<span class="number">0</span>]))</span><br><span class="line">            l.popleft()</span><br><span class="line">            root.left = rdeserialize(l)</span><br><span class="line">            root.right = rdeserialize(l)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        dlist = collections.deque(data.split(<span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">        root = rdeserialize(dlist)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hjsang.github.io/2020/12/24/Leetcode-297-Serialize-and-Deserialize-Binary-Tree/" data-id="ckj4sm31e0009rdu28i1f60q2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/source/tags/BFS/" rel="tag">BFS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/source/tags/DFS/" rel="tag">DFS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/source/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/source/tags/Tree/" rel="tag">Tree</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Reading-Note-Improving-Web-Search-Ranking-by-Incorporating-User-Behavior-Information" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/23/Reading-Note-Improving-Web-Search-Ranking-by-Incorporating-User-Behavior-Information/" class="article-date">
  <time datetime="2020-12-23T16:08:03.000Z" itemprop="datePublished">2020-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/23/Reading-Note-Improving-Web-Search-Ranking-by-Incorporating-User-Behavior-Information/">Reading Note: Improving Web Search Ranking by Incorporating User Behavior Information</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p> This paper explores whether implicit feedback can be helpful in realistic environments, where user feedback can be noisy and a web search engine already uses hundreds of features and is heavily tuned.</p>
<p> <strong>Contributions</strong>:</p>
<ul>
<li>Analysis of alternatives for incoporating user behavior into web search ranking</li>
<li>An application of a robust implicit feedback model</li>
<li>A large scale evaluation</li>
</ul>
<h2 id="Incorporating-Implicit-Feedback"><a href="#Incorporating-Implicit-Feedback" class="headerlink" title="Incorporating Implicit Feedback"></a>Incorporating Implicit Feedback</h2><ul>
<li><p><strong>Treating implicit feedback as independent evidence for ranking results</strong>:</p>
<ul>
<li>Re-rank the results obtained by a web search engine </li>
<li>Each result is assigned a score according to expected relevance/user satisfaction</li>
<li>For a given query <strong>q</strong>, the implicit score $IS_d$ is computed for each result $d$ from available user interaction features</li>
<li>The implicit score results in the implicit rank $I_d$ for each result</li>
<li>The original score rank is $O_d$</li>
<li>We compute the merged score: $S_M(d)= w_I \frac{1}{I_d+1}+\frac{1}{O_d+1}$ if implicit feedback exists for $d$.</li>
<li>Otherwise, $S_M(d) = \frac{1}{O_d}$</li>
</ul>
</li>
<li><p><strong>Ranking with implicit feedback features</strong>:</p>
<ul>
<li>Incorporate implicit feedback features directly as features for the ranking algorithm.</li>
<li>This model requires a ranking algorithm to be robust to missing values: more than 50% of queries are unique( without previous implicit feedback)</li>
<li>Use a 2-layer implementation of RankNet in order to model non-linear relationships between features.</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hjsang.github.io/2020/12/23/Reading-Note-Improving-Web-Search-Ranking-by-Incorporating-User-Behavior-Information/" data-id="ckj4sm31g000brdu2hxnzbb9y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/source/tags/Implicit-relevance-feedback/" rel="tag">Implicit relevance feedback</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/source/tags/Paper-reading-notes/" rel="tag">Paper reading notes</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/source/tags/Web-Search/" rel="tag">Web Search</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/source/tags/Web-search-ranking/" rel="tag">Web search ranking</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Leetcode-199-Binary-Tree-Right-Side-View" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/23/Leetcode-199-Binary-Tree-Right-Side-View/" class="article-date">
  <time datetime="2020-12-23T13:56:27.000Z" itemprop="datePublished">2020-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/23/Leetcode-199-Binary-Tree-Right-Side-View/">Leetcode 199: Binary Tree Right Side View</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Medium</p>
<p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<p><strong>Example</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,null,5,null,4]</span><br><span class="line">Output: [1, 3, 4]</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure></p>
<p>When you need to search some values from the tree, please consider the tree traversal methods: BFS and DFS. For this specific problem, we need to find the most right elements at each level. Therefore, we need to find the level information and save all elements from the same level. It seems that BFS is easy to use. In most cases, dfs also performs the similar function of BFS in a different traversal trace. </p>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>Breath-First-Search (BFS): </p>
<ul>
<li>Initial current node list: curNode = [root]</li>
<li>while curNode is not empty:<ul>
<li>nextNode = [j for i in curNode for j in (i.left, i.right) if j]</li>
<li>the most right element is nextNode[-1].val</li>
<li>curNode = nextNode</li>
</ul>
</li>
</ul>
<p>Please consider the corner case: tree is empty.</p>
<p>Please make sure the node is valid when extracting the val.</p>
<p><strong>Iterative Python Code: BFS</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self,root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        curNode=[root]</span><br><span class="line">        res.append(root.val)</span><br><span class="line">        <span class="keyword">while</span> curNode:</span><br><span class="line">            nextNode =[j <span class="keyword">for</span> i <span class="keyword">in</span> curNode <span class="keyword">for</span> j <span class="keyword">in</span> (i.left,i.right) <span class="keyword">if</span> j]</span><br><span class="line">            <span class="keyword">if</span> nextNode:</span><br><span class="line">                res.append(nextNode[-<span class="number">1</span>].val)</span><br><span class="line">            curNode = nextNode</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<ul>
<li>The time complexity is <strong>O(n)</strong>: single loop traversal </li>
<li>The space complexity is <strong>O(log(n))</strong>: CurNode and NextNode for level elements.</li>
</ul>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>Depth-First-Search (DFS): Easy to implement by recursive way but difficult to use iterative way</p>
<p><strong>Recursive DFS python code</strong>:</p>
<ul>
<li>Use a list of list  to save all tree elements and the index of the list is the level+1 of the tree</li>
<li>if length of the list &lt; level +1, we need to add another list for new level</li>
<li>To write the dfs function using the recursive way, 1) terminate confition first, 2) when the valid node comes, perform operation, 3) then, consider children nodes.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        self.dfs(root,res,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> [i[-<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> res]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self,root,res, level</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; level+<span class="number">1</span>:</span><br><span class="line">            res.append([])</span><br><span class="line">        res[level].append(root.val)</span><br><span class="line">        self.dfs(root.left,res,level+<span class="number">1</span>)</span><br><span class="line">        self.dfs(root.right,res,level+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Iterative BFS python code</strong>:</p>
<ul>
<li>Use stack</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        stack = [(root,<span class="number">0</span>)]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, level = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(res)&lt;level+<span class="number">1</span>:</span><br><span class="line">                    res.append([])</span><br><span class="line">                res[level].append(node.val)</span><br><span class="line">                stack.append((node.right,level+<span class="number">1</span>))</span><br><span class="line">                stack.append((node.left,level+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> [i[-<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> res]</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hjsang.github.io/2020/12/23/Leetcode-199-Binary-Tree-Right-Side-View/" data-id="ckj4sm31c0008rdu22na44yeu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/source/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/source/tags/Tree/" rel="tag">Tree</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/source/tags/bfs/" rel="tag">bfs</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/source/tags/dfs/" rel="tag">dfs</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/BFS/" rel="tag">BFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/Binary-Search/" rel="tag">Binary Search</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/Binary-Tree/" rel="tag">Binary Tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/CF/" rel="tag">CF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/CTR-prediction/" rel="tag">CTR prediction</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/DFS/" rel="tag">DFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/Deep-Crossing/" rel="tag">Deep Crossing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/Hard/" rel="tag">Hard</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/Implicit-relevance-feedback/" rel="tag">Implicit relevance feedback</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/Math/" rel="tag">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/Paper-reading-notes/" rel="tag">Paper reading notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/Recommendation-system/" rel="tag">Recommendation system</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/Stack/" rel="tag">Stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/Traversal/" rel="tag">Traversal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/Tree/" rel="tag">Tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/Tree-Traversal/" rel="tag">Tree Traversal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/Two-pointers/" rel="tag">Two pointers</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/Web-Search/" rel="tag">Web Search</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/Web-search-ranking/" rel="tag">Web search ranking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/Wide-Deep/" rel="tag">Wide & Deep</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/bfs/" rel="tag">bfs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/data-science/" rel="tag">data science</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/deep-learning/" rel="tag">deep learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/dfs/" rel="tag">dfs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/pandas/" rel="tag">pandas</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/paper/" rel="tag">paper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/source/tags/recommender-system/" rel="tag">recommender system</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/source/tags/Algorithm/" style="font-size: 10px;">Algorithm</a> <a href="/source/tags/BFS/" style="font-size: 10px;">BFS</a> <a href="/source/tags/Binary-Search/" style="font-size: 10px;">Binary Search</a> <a href="/source/tags/Binary-Tree/" style="font-size: 10px;">Binary Tree</a> <a href="/source/tags/CF/" style="font-size: 10px;">CF</a> <a href="/source/tags/CTR-prediction/" style="font-size: 12px;">CTR prediction</a> <a href="/source/tags/DFS/" style="font-size: 10px;">DFS</a> <a href="/source/tags/Deep-Crossing/" style="font-size: 10px;">Deep Crossing</a> <a href="/source/tags/Hard/" style="font-size: 10px;">Hard</a> <a href="/source/tags/Implicit-relevance-feedback/" style="font-size: 10px;">Implicit relevance feedback</a> <a href="/source/tags/LeetCode/" style="font-size: 12px;">LeetCode</a> <a href="/source/tags/Leetcode/" style="font-size: 20px;">Leetcode</a> <a href="/source/tags/Math/" style="font-size: 10px;">Math</a> <a href="/source/tags/Paper-reading-notes/" style="font-size: 10px;">Paper reading notes</a> <a href="/source/tags/Recommendation-system/" style="font-size: 14px;">Recommendation system</a> <a href="/source/tags/Stack/" style="font-size: 18px;">Stack</a> <a href="/source/tags/Traversal/" style="font-size: 10px;">Traversal</a> <a href="/source/tags/Tree/" style="font-size: 16px;">Tree</a> <a href="/source/tags/Tree-Traversal/" style="font-size: 10px;">Tree Traversal</a> <a href="/source/tags/Two-pointers/" style="font-size: 10px;">Two pointers</a> <a href="/source/tags/Web-Search/" style="font-size: 10px;">Web Search</a> <a href="/source/tags/Web-search-ranking/" style="font-size: 10px;">Web search ranking</a> <a href="/source/tags/Wide-Deep/" style="font-size: 10px;">Wide & Deep</a> <a href="/source/tags/bfs/" style="font-size: 10px;">bfs</a> <a href="/source/tags/data-science/" style="font-size: 10px;">data science</a> <a href="/source/tags/deep-learning/" style="font-size: 10px;">deep learning</a> <a href="/source/tags/dfs/" style="font-size: 10px;">dfs</a> <a href="/source/tags/pandas/" style="font-size: 10px;">pandas</a> <a href="/source/tags/paper/" style="font-size: 10px;">paper</a> <a href="/source/tags/recommender-system/" style="font-size: 10px;">recommender system</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/18/Leetcode-829-Consecutive-Numbers-Sum/">Leetcode 829: Consecutive Numbers Sum</a>
          </li>
        
          <li>
            <a href="/2021/01/16/Note-for-Deep-Crossing/">Note for Deep Crossing</a>
          </li>
        
          <li>
            <a href="/2021/01/16/Note-for-AutoRec-Autoencoders-Meet-Collaborative-Filtering/">Note for AutoRec: Autoencoders Meet Collaborative Filtering</a>
          </li>
        
          <li>
            <a href="/2021/01/16/Note-for-Wide-and-Deep-Learning-for-Recommendation-Systems/">Note for Wide and Deep Learning for Recommendation Systems</a>
          </li>
        
          <li>
            <a href="/2021/01/04/Leetcode-1209-Remove-All-Adjacent-Duplicates-in-String-II/">Leetcode 1209: Remove All Adjacent Duplicates in String II</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Hejian Sang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>